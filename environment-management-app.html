<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Environment Management System</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      :root {
        --primary-color: #2563eb;
        --primary-hover: #1d4ed8;
        --secondary-color: #64748b;
        --success-color: #059669;
        --warning-color: #d97706;
        --danger-color: #dc2626;
        --bg-primary: #ffffff;
        --bg-secondary: #f8fafc;
        --bg-tertiary: #f1f5f9;
        --text-primary: #1e293b;
        --text-secondary: #64748b;
        --border-color: #e2e8f0;
        --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
      }

      body {
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, sans-serif;
        background: var(--bg-secondary);
        color: var(--text-primary);
        line-height: 1.5;
      }

      .app-container {
        display: flex;
        flex-direction: column;
        height: 100vh;
      }

      .header {
        background: var(--bg-primary);
        border-bottom: 1px solid var(--border-color);
        padding: 1rem 1.5rem;
        box-shadow: var(--shadow-sm);
      }

      .header h1 {
        font-size: 1.5rem;
        font-weight: 600;
        color: var(--text-primary);
      }

      .nav-tabs {
        display: flex;
        background: var(--bg-primary);
        border-bottom: 1px solid var(--border-color);
        overflow-x: auto;
      }

      .nav-tab {
        padding: 1rem 1.5rem;
        cursor: pointer;
        border: none;
        background: transparent;
        font-size: 0.875rem;
        font-weight: 500;
        color: var(--text-secondary);
        transition: all 0.2s ease;
        border-bottom: 2px solid transparent;
        white-space: nowrap;
      }

      .nav-tab:hover {
        background: var(--bg-tertiary);
        color: var(--text-primary);
      }

      .nav-tab.active {
        color: var(--primary-color);
        border-bottom-color: var(--primary-color);
        background: var(--bg-tertiary);
      }

      .main-content {
        flex: 1;
        overflow: hidden;
        display: flex;
      }

      .tab-pane {
        display: none;
        flex: 1;
        padding: 1.5rem;
        overflow-y: auto;
      }

      .tab-pane.active {
        display: block;
      }

      .card {
        background: var(--bg-primary);
        border-radius: 0.5rem;
        padding: 1.5rem;
        box-shadow: var(--shadow-md);
        border: 1px solid var(--border-color);
        margin-bottom: 1.5rem;
      }

      .card-title {
        font-size: 1.25rem;
        font-weight: 600;
        margin-bottom: 1rem;
        color: var(--text-primary);
      }

      .form-group {
        margin-bottom: 1rem;
      }

      .form-label {
        display: block;
        margin-bottom: 0.5rem;
        font-weight: 500;
        color: var(--text-primary);
        font-size: 0.875rem;
      }

      .form-input,
      .form-select,
      .form-textarea {
        width: 100%;
        padding: 0.75rem;
        border: 1px solid var(--border-color);
        border-radius: 0.375rem;
        font-size: 0.875rem;
        transition:
          border-color 0.2s ease,
          box-shadow 0.2s ease;
        background: var(--bg-primary);
      }

      .form-input:focus,
      .form-select:focus,
      .form-textarea:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
      }

      .btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0.75rem 1rem;
        border: none;
        border-radius: 0.375rem;
        font-size: 0.875rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
        text-decoration: none;
        gap: 0.5rem;
      }

      .btn-primary {
        background: var(--primary-color);
        color: white;
      }

      .btn-primary:hover:not(:disabled) {
        background: var(--primary-hover);
      }

      .btn-secondary {
        background: var(--secondary-color);
        color: white;
      }

      .btn-secondary:hover:not(:disabled) {
        background: #475569;
      }

      .btn-success {
        background: var(--success-color);
        color: white;
      }

      .btn-success:hover:not(:disabled) {
        background: #047857;
      }

      .btn-danger {
        background: var(--danger-color);
        color: white;
      }

      .btn-danger:hover:not(:disabled) {
        background: #b91c1c;
      }

      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .btn-group {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
      }

      .relationships-container,
      .config-container {
        border: 1px solid var(--border-color);
        border-radius: 0.375rem;
        padding: 1rem;
        background: var(--bg-tertiary);
      }

      .relationship-item,
      .config-item {
        display: flex;
        gap: 0.5rem;
        align-items: center;
        margin-bottom: 0.5rem;
        padding: 0.5rem;
        background: var(--bg-primary);
        border: 1px solid var(--border-color);
        border-radius: 0.25rem;
      }

      .relationship-item:last-child,
      .config-item:last-child {
        margin-bottom: 0;
      }

      .relationship-item select,
      .relationship-item input,
      .config-item input {
        flex: 1;
        margin: 0;
      }

      .config-key,
      .config-value {
        flex: 1;
      }

      .btn-sm {
        padding: 0.375rem 0.75rem;
        font-size: 0.75rem;
      }

      .remove-relationship {
        background: var(--danger-color);
        color: white;
        border: none;
        border-radius: 0.25rem;
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 12px;
      }

      .relationships-list {
        max-height: 400px;
        overflow-y: auto;
      }

      .relationship-record {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.75rem;
        margin-bottom: 0.5rem;
        background: var(--bg-primary);
        border: 1px solid var(--border-color);
        border-radius: 0.375rem;
      }

      .relationship-info {
        flex: 1;
      }

      .relationship-source,
      .relationship-target {
        font-weight: 500;
        color: var(--primary-color);
      }

      .relationship-type {
        font-size: 0.875rem;
        color: var(--text-secondary);
        margin: 0.25rem 0;
      }

      .grid-2 {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1.5rem;
      }

      @media (max-width: 768px) {
        .grid-2 {
          grid-template-columns: 1fr;
        }
      }

      .alert {
        padding: 0.75rem 1rem;
        border-radius: 0.375rem;
        margin-bottom: 1rem;
        font-size: 0.875rem;
      }

      .alert-success {
        background: #dcfce7;
        color: #166534;
        border: 1px solid #bbf7d0;
      }

      .alert-error {
        background: #fee2e2;
        color: #991b1b;
        border: 1px solid #fecaca;
      }

      .alert-info {
        background: #dbeafe;
        color: #1e40af;
        border: 1px solid #bfdbfe;
      }

      .loading {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 2rem;
        color: var(--text-secondary);
        font-size: 0.875rem;
      }

      .spinner {
        display: inline-block;
        width: 1rem;
        height: 1rem;
        border: 2px solid var(--border-color);
        border-top: 2px solid var(--primary-color);
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-right: 0.5rem;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .grid-2 {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1.5rem;
      }

      .entity-list {
        max-height: 400px;
        overflow-y: auto;
        border: 1px solid var(--border-color);
        border-radius: 0.375rem;
      }

      .entity-item {
        padding: 1rem;
        border-bottom: 1px solid var(--border-color);
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 1rem;
      }

      .entity-item:last-child {
        border-bottom: none;
      }

      .entity-info {
        flex: 1;
        min-width: 0;
      }

      .entity-name {
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: 0.25rem;
      }

      .entity-type {
        font-size: 0.75rem;
        font-weight: 500;
        color: var(--primary-color);
        margin-bottom: 0.25rem;
      }

      .entity-details {
        font-size: 0.75rem;
        color: var(--text-secondary);
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .graph-container {
        height: 700px;
        border: 1px solid var(--border-color);
        border-radius: 0.375rem;
        background: var(--bg-primary);
        position: relative;
      }

      .graph-stats {
        display: flex;
        gap: 1rem;
        margin-bottom: 1rem;
      }

      .stat-item {
        padding: 0.5rem 0.75rem;
        background: var(--bg-tertiary);
        border-radius: 0.375rem;
        font-size: 0.75rem;
        font-weight: 500;
        color: var(--text-secondary);
      }

      .query-result {
        background: var(--bg-tertiary);
        border: 1px solid var(--border-color);
        border-radius: 0.375rem;
        padding: 1rem;
        max-height: 400px;
        overflow-y: auto;
        font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
        font-size: 0.75rem;
        line-height: 1.4;
      }

      .query-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.75rem;
      }

      .query-table th,
      .query-table td {
        border: 1px solid var(--border-color);
        padding: 0.5rem;
        text-align: left;
      }

      .query-table th {
        background: var(--bg-secondary);
        font-weight: 600;
      }

      .danger-zone {
        border: 2px solid var(--danger-color);
        border-radius: 0.5rem;
        padding: 1rem;
        margin-top: 1.5rem;
      }

      .danger-zone-title {
        color: var(--danger-color);
        font-weight: 600;
        margin-bottom: 0.5rem;
      }

      .connection-status {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        margin-bottom: 1rem;
        padding: 0.75rem;
        background: var(--bg-tertiary);
        border-radius: 0.375rem;
        font-size: 0.875rem;
      }

      .status-indicator {
        width: 0.5rem;
        height: 0.5rem;
        border-radius: 50%;
      }

      .status-connected {
        background: var(--success-color);
      }

      .status-disconnected {
        background: var(--danger-color);
      }

      .status-checking {
        background: var(--warning-color);
        animation: pulse 1.5s ease-in-out infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
      }

      /* Graph styles */
      .node {
        cursor: pointer;
        stroke-width: 2px;
      }

      .node:hover {
        stroke-width: 3px;
      }

      .link {
        stroke: #94a3b8;
        stroke-opacity: 0.7;
        stroke-width: 0.8px;
      }

      .node-label {
        font-size: 10px;
        font-weight: 500;
        text-anchor: middle;
        pointer-events: none;
        fill: var(--text-primary);
      }

      .edge-label {
        font-size: 8px;
        font-weight: 500;
        text-anchor: middle;
        pointer-events: none;
        fill: #475569;
        paint-order: stroke fill;
        stroke: white;
        stroke-width: 1;
        stroke-linejoin: round;
      }

      .tooltip {
        position: absolute;
        background: rgba(17, 24, 39, 0.98);
        color: white;
        padding: 12px;
        border-radius: 8px;
        font-size: 0.75rem;
        pointer-events: auto;
        opacity: 0;
        transition: opacity 0.2s ease-in-out;
        z-index: 1000;
        max-width: 500px;
        min-width: 300px;
        line-height: 1.3;
        box-shadow:
          0 10px 25px -3px rgba(0, 0, 0, 0.4),
          0 4px 6px -2px rgba(0, 0, 0, 0.2);
        border: 1px solid rgba(75, 85, 99, 0.6);
        backdrop-filter: blur(8px);
        max-height: 80vh;
        overflow-y: auto;
        overflow-x: hidden;
        word-wrap: break-word;
        overflow-wrap: break-word;
      }

      .tooltip table {
        border-collapse: collapse;
        width: 100%;
        table-layout: fixed;
      }

      /* Context Menu Styles */
      .context-menu {
        position: absolute;
        background: white;
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        box-shadow:
          0 4px 6px -1px rgba(0, 0, 0, 0.1),
          0 2px 4px -1px rgba(0, 0, 0, 0.06);
        z-index: 10000;
        min-width: 200px;
        padding: 4px 0;
      }

      .context-menu-item {
        padding: 10px 16px;
        cursor: pointer;
        font-size: 14px;
        color: #374151;
        transition: background-color 0.15s ease;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .context-menu-item:hover {
        background-color: #f3f4f6;
      }

      .context-menu-danger {
        color: #dc2626;
      }

      .context-menu-danger:hover {
        background-color: #fee2e2;
      }

      .tooltip table th,
      .tooltip table td {
        text-align: left;
        vertical-align: top;
        word-wrap: break-word;
        overflow-wrap: break-word;
        word-break: break-word;
        max-width: 0;
      }

      .tooltip table th {
        font-weight: 600;
        width: 35%;
      }

      .tooltip table td {
        width: 65%;
        overflow-wrap: anywhere;
        hyphens: auto;
      }

      /* Edit Modal Styles */
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 9999;
        overflow-y: auto;
        backdrop-filter: blur(4px);
      }

      .modal-content {
        max-width: 600px;
        margin: 50px auto;
        background: var(--bg-primary);
        border-radius: 0.5rem;
        padding: 2rem;
        box-shadow:
          0 20px 25px -5px rgba(0, 0, 0, 0.1),
          0 10px 10px -5px rgba(0, 0, 0, 0.04);
        animation: modalSlideIn 0.3s ease-out;
      }

      @keyframes modalSlideIn {
        from {
          opacity: 0;
          transform: translateY(-20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.5rem;
        padding-bottom: 1rem;
        border-bottom: 1px solid var(--border-color);
      }

      .modal-header h2 {
        margin: 0;
        font-size: 1.5rem;
        font-weight: 600;
        color: var(--text-primary);
      }

      .modal-close {
        background: none;
        border: none;
        font-size: 1.5rem;
        cursor: pointer;
        color: var(--text-secondary);
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 0.25rem;
        transition: all 0.2s;
      }

      .modal-close:hover {
        background: var(--bg-tertiary);
        color: var(--text-primary);
      }

      /* Searchable dropdown styles */
      .searchable-dropdown {
        position: relative;
        width: 100%;
      }

      .searchable-dropdown .dropdown-search {
        width: 100%;
        padding: 0.625rem 0.75rem;
        border: 1px solid var(--border-color);
        border-radius: 0.375rem;
        font-size: 0.875rem;
        background: var(--bg-primary);
        color: var(--text-primary);
        transition: border-color 0.2s;
      }

      .searchable-dropdown .dropdown-search:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
      }

      .searchable-dropdown .dropdown-list {
        display: none;
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        max-height: 200px;
        overflow-y: auto;
        background: var(--bg-primary);
        border: 1px solid var(--border-color);
        border-top: none;
        border-radius: 0 0 0.375rem 0.375rem;
        z-index: 100;
        box-shadow: var(--shadow-md);
      }

      .searchable-dropdown .dropdown-list.open {
        display: block;
      }

      .searchable-dropdown .dropdown-option {
        padding: 0.5rem 0.75rem;
        cursor: pointer;
        font-size: 0.875rem;
        color: var(--text-primary);
        transition: background 0.15s;
      }

      .searchable-dropdown .dropdown-option:hover,
      .searchable-dropdown .dropdown-option.highlighted {
        background: var(--bg-tertiary);
      }

      .searchable-dropdown .dropdown-option.selected {
        background: #dbeafe;
        color: var(--primary-color);
        font-weight: 500;
      }

      .searchable-dropdown .dropdown-no-results {
        padding: 0.75rem;
        text-align: center;
        color: var(--text-secondary);
        font-size: 0.8rem;
      }

      @media (max-width: 768px) {
        .grid-2 {
          grid-template-columns: 1fr;
        }

        .nav-tab {
          padding: 0.75rem 1rem;
          font-size: 0.75rem;
        }

        .card {
          padding: 1rem;
        }
      }
    </style>
    <!-- SheetJS library for Excel parsing -->
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
  </head>
  <body>
    <div class="app-container">
      <header class="header">
        <h1>Environment Management System</h1>
      </header>

      <nav class="nav-tabs">
        <button class="nav-tab active" data-tab="add-entity">Add Entity</button>
        <button class="nav-tab" data-tab="query-data">Query Data</button>
        <button class="nav-tab" data-tab="visualize">Visualize</button>
        <button class="nav-tab" data-tab="relationships">Relationships</button>
        <button class="nav-tab" data-tab="delete-entity">
          Manage Entities
        </button>
        <button class="nav-tab" data-tab="bulk-import">Bulk Import</button>
        <button class="nav-tab" data-tab="admin">Admin</button>
      </nav>

      <div class="main-content">
        <!-- Add Entity Tab -->
        <div id="add-entity" class="tab-pane active">
          <div class="connection-status" id="connection-status">
            <div class="status-indicator status-checking"></div>
            <span>Checking connection...</span>
            <button
              class="btn btn-secondary"
              onclick="testDirectApi()"
              style="
                margin-left: auto;
                padding: 0.25rem 0.5rem;
                font-size: 0.75rem;
              "
              title="Test Lambda API connections"
            >
              Test APIs
            </button>
          </div>

          <div class="card">
            <h2 class="card-title">Create New Entity</h2>
            <div id="add-alerts"></div>

            <form id="add-entity-form">
              <div class="form-group">
                <label class="form-label" for="entity-type">Entity Type</label>
                <select
                  id="entity-type"
                  name="entity-type"
                  class="form-select"
                  required
                >
                  <option value="">Select entity type</option>
                  <option value="Environment">Environment</option>
                  <option value="Application">Application</option>
                  <option value="Integration">Integration</option>
                </select>
              </div>

              <div class="form-group">
                <label class="form-label" for="entity-name">Name</label>
                <input
                  type="text"
                  id="entity-name"
                  name="entity-name"
                  class="form-input"
                  required
                  placeholder="Enter entity name"
                />
              </div>

              <div class="form-group">
                <label class="form-label" for="entity-description"
                  >Description</label
                >
                <textarea
                  id="entity-description"
                  name="entity-description"
                  class="form-textarea"
                  rows="3"
                  placeholder="Enter description"
                ></textarea>
              </div>

              <!-- Environment specific fields -->
              <div id="environment-fields" style="display: none">
                <div class="form-group">
                  <label class="form-label" for="env-region">Region</label>
                  <input
                    type="text"
                    id="env-region"
                    name="env-region"
                    class="form-input"
                    placeholder="e.g., us-east-1, eu-west-1 (optional)"
                  />
                </div>
                <div class="form-group">
                  <label class="form-label" for="env-endpoint">Endpoint</label>
                  <input
                    type="url"
                    id="env-endpoint"
                    name="env-endpoint"
                    class="form-input"
                    placeholder="https://example.com"
                  />
                </div>
                <div class="form-group">
                  <label class="form-label" for="env-owner">Owner</label>
                  <input
                    type="text"
                    id="env-owner"
                    name="env-owner"
                    class="form-input"
                    placeholder="Team or person name"
                  />
                </div>
              </div>

              <!-- Application specific fields -->
              <div id="application-fields" style="display: none">
                <div class="form-group">
                  <label class="form-label" for="app-version">Version</label>
                  <input
                    type="text"
                    id="app-version"
                    name="app-version"
                    class="form-input"
                    placeholder="e.g., 1.0.0"
                  />
                </div>
                <div class="form-group">
                  <label class="form-label" for="app-owner">Owner</label>
                  <input
                    type="text"
                    id="app-owner"
                    name="app-owner"
                    class="form-input"
                    placeholder="Development team"
                  />
                </div>
              </div>

              <!-- Integration specific fields -->
              <div id="integration-fields" style="display: none">
                <div class="form-group">
                  <label class="form-label" for="int-source-service"
                    >Source Service</label
                  >
                  <select
                    id="int-source-service"
                    name="int-source-service"
                    class="form-select"
                  >
                    <option value="">Select source service</option>
                  </select>
                </div>
                <div class="form-group">
                  <label class="form-label" for="int-target-service"
                    >Target Service</label
                  >
                  <select
                    id="int-target-service"
                    name="int-target-service"
                    class="form-select"
                  >
                    <option value="">Select target service</option>
                  </select>
                </div>
                <div class="form-group">
                  <label class="form-label" for="int-protocol">Protocol</label>
                  <select
                    id="int-protocol"
                    name="int-protocol"
                    class="form-select"
                  >
                    <option value="">Select protocol</option>
                    <option value="REST">REST</option>
                    <option value="SOAP">SOAP</option>
                    <option value="GraphQL">GraphQL</option>
                    <option value="gRPC">gRPC</option>
                  </select>
                </div>
                <div class="form-group">
                  <label class="form-label" for="int-owner">Owner</label>
                  <input
                    type="text"
                    id="int-owner"
                    name="int-owner"
                    class="form-input"
                    placeholder="Integration team"
                  />
                </div>
              </div>

              <!-- Custom Configuration Section -->
              <div class="form-group">
                <div
                  style="
                    display: flex;
                    align-items: center;
                    cursor: pointer;
                    user-select: none;
                    margin-bottom: 0.5rem;
                  "
                  onclick="toggleCreateConfigSection()"
                >
                  <span
                    id="create-config-toggle-icon"
                    style="
                      margin-right: 0.5rem;
                      font-size: 0.75rem;
                      transition: transform 0.2s;
                    "
                    >&#9654;</span
                  >
                  <label
                    class="form-label"
                    style="margin-bottom: 0; cursor: pointer"
                    >Custom Configuration (Optional)</label
                  >
                </div>
                <div id="create-config-section" style="display: none">
                  <div class="config-container">
                    <div id="config-list"></div>
                    <button
                      type="button"
                      class="btn btn-secondary btn-sm"
                      onclick="addConfigField()"
                    >
                      Add Configuration
                    </button>
                  </div>
                </div>
              </div>

              <!-- Relationships Section -->
              <div class="form-group">
                <label class="form-label">Relationships</label>
                <div class="relationships-container">
                  <div id="relationships-list"></div>
                  <button
                    type="button"
                    class="btn btn-secondary btn-sm"
                    onclick="addRelationshipField()"
                  >
                    Add Relationship
                  </button>
                </div>
              </div>

              <button type="submit" class="btn btn-primary">
                Create Entity
              </button>
            </form>
          </div>
        </div>

        <!-- Query Data Tab -->
        <div id="query-data" class="tab-pane">
          <div class="grid-2">
            <div class="card">
              <h2 class="card-title">Execute Queries</h2>

              <div class="btn-group" style="margin-bottom: 1rem">
                <button class="btn btn-secondary" onclick="queryAllEntities()">
                  All Entities
                </button>
                <button class="btn btn-secondary" onclick="queryEnvironments()">
                  Environments
                </button>
                <button class="btn btn-secondary" onclick="queryApplications()">
                  Applications
                </button>
                <button class="btn btn-secondary" onclick="queryIntegrations()">
                  Integrations
                </button>
              </div>

              <div class="form-group">
                <label class="form-label" for="custom-query"
                  >Custom SPARQL Query</label
                >
                <textarea
                  id="custom-query"
                  class="form-textarea"
                  rows="10"
                  placeholder="Enter your SPARQL query here..."
                >
PREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;
PREFIX env: &lt;http://neptune.aws.com/envmgmt/ontology/&gt;

SELECT ?entity ?type ?name
WHERE {
    ?entity rdf:type ?type ;
            env:name ?name .
}
LIMIT 10</textarea
                >
              </div>

              <button class="btn btn-primary" onclick="executeCustomQuery()">
                Execute Query
              </button>
            </div>

            <div class="card">
              <h2 class="card-title">Query Results</h2>
              <div
                class="btn-group"
                style="margin-bottom: 1rem; display: none"
                id="query-actions"
              >
                <button
                  class="btn btn-primary"
                  onclick="visualizeQueryResults()"
                >
                  Visualize as Graph
                </button>
                <button
                  class="btn btn-secondary"
                  onclick="exportQueryResults()"
                >
                  Export Results
                </button>
              </div>
              <div id="query-results" class="query-result">
                <div class="loading">Execute a query to see results</div>
              </div>
            </div>
          </div>
        </div>

        <!-- Visualize Tab -->
        <div id="visualize" class="tab-pane">
          <div class="card">
            <div class="btn-group" style="margin-bottom: 1rem">
              <button class="btn btn-primary" onclick="loadNetworkData()">
                Refresh Graph
              </button>
              <button class="btn btn-secondary" onclick="resetZoom()">
                Reset Zoom
              </button>
              <button class="btn btn-secondary" onclick="fitGraphToViewport()">
                Fit to View
              </button>
              <button class="btn btn-secondary" onclick="exportGraph()">
                Export Data
              </button>
              <button class="btn btn-secondary" onclick="exportGraphAsImage()">
                Export as Image
              </button>
              <button
                class="btn btn-secondary"
                id="toggle-edge-labels"
                onclick="toggleEdgeLabels()"
              >
                Hide Edge Labels
              </button>
            </div>

            <div class="graph-stats">
              <div class="stat-item">Nodes: <span id="node-count">0</span></div>
              <div class="stat-item">Edges: <span id="edge-count">0</span></div>
            </div>

            <div class="graph-container">
              <svg id="network-graph"></svg>
            </div>
          </div>
        </div>

        <!-- Relationships Tab -->
        <div id="relationships" class="tab-pane">
          <div class="card">
            <h2 class="card-title">Manage Relationships</h2>
            <div id="relationships-alerts"></div>

            <div class="grid-2">
              <div class="card">
                <h3 class="card-title">Create New Relationship</h3>

                <div class="btn-group" style="margin-bottom: 1rem">
                  <button
                    type="button"
                    class="btn btn-secondary"
                    onclick="refreshEntityDropdowns()"
                  >
                    Refresh Entity Lists
                  </button>
                </div>

                <form id="create-relationship-form">
                  <div class="form-group">
                    <label class="form-label" for="source-entity"
                      >Source Entity</label
                    >
                    <div class="searchable-dropdown" id="source-entity-wrapper">
                      <input
                        type="text"
                        class="dropdown-search"
                        id="source-entity-search"
                        placeholder="Search source entity..."
                        autocomplete="off"
                      />
                      <div class="dropdown-list" id="source-entity-list"></div>
                      <select
                        id="source-entity"
                        class="form-select"
                        required
                        style="display: none"
                      >
                        <option value="">Select source entity</option>
                      </select>
                    </div>
                  </div>

                  <div class="form-group">
                    <label class="form-label" for="rel-type"
                      >Relationship Type</label
                    >
                    <div class="searchable-dropdown" id="rel-type-wrapper">
                      <input
                        type="text"
                        class="dropdown-search"
                        id="rel-type-search"
                        placeholder="Search relationship type..."
                        autocomplete="off"
                      />
                      <div class="dropdown-list" id="rel-type-list"></div>
                      <select
                        id="rel-type"
                        class="form-select"
                        required
                        style="display: none"
                      >
                        <option value="">Select relationship type</option>
                        <option value="dependsOn">Depends On</option>
                        <option value="integrates">Integrates With</option>
                        <option value="deploysTo">Deploys To</option>
                        <option value="configures">Configures</option>
                        <option value="monitors">Monitors</option>
                        <option value="connects">Connects To</option>
                      </select>
                    </div>
                  </div>

                  <div class="form-group">
                    <label class="form-label" for="target-entity"
                      >Target Entity</label
                    >
                    <div class="searchable-dropdown" id="target-entity-wrapper">
                      <input
                        type="text"
                        class="dropdown-search"
                        id="target-entity-search"
                        placeholder="Search target entity..."
                        autocomplete="off"
                      />
                      <div class="dropdown-list" id="target-entity-list"></div>
                      <select
                        id="target-entity"
                        class="form-select"
                        required
                        style="display: none"
                      >
                        <option value="">Select target entity</option>
                      </select>
                    </div>
                  </div>

                  <button type="submit" class="btn btn-primary">
                    Create Relationship
                  </button>
                </form>
              </div>

              <div class="card">
                <h3 class="card-title">Existing Relationships</h3>
                <div class="btn-group" style="margin-bottom: 1rem">
                  <button
                    class="btn btn-secondary"
                    onclick="loadExistingRelationships()"
                  >
                    Refresh List
                  </button>
                </div>
                <div id="existing-relationships" class="relationships-list">
                  <div class="loading">Click refresh to load relationships</div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Delete Entity Tab -->
        <div id="delete-entity" class="tab-pane">
          <div class="card">
            <h2 class="card-title">Manage Entities</h2>
            <div id="delete-alerts"></div>

            <div
              style="
                display: flex;
                gap: 0.75rem;
                align-items: flex-end;
                margin-bottom: 0.25rem;
              "
            >
              <div class="form-group" style="flex: 1; margin-bottom: 0">
                <label class="form-label" for="search-entity"
                  >Search Entities</label
                >
                <input
                  type="text"
                  id="search-entity"
                  class="form-input"
                  placeholder="Type to search entities..."
                  oninput="searchEntities()"
                />
              </div>
              <button
                type="button"
                class="btn btn-secondary"
                onclick="loadEntitiesForDeletion()"
                style="white-space: nowrap; height: fit-content"
              >
                ↻ Refresh List
              </button>
            </div>

            <div id="entity-list" class="entity-list">
              <div class="loading">
                <div class="spinner"></div>
                Loading entities...
              </div>
            </div>
          </div>
        </div>

        <!-- Bulk Import Tab -->
        <div id="bulk-import" class="tab-pane">
          <div class="card">
            <h2 class="card-title">Bulk Import Entities</h2>
            <div id="bulk-alerts"></div>

            <p style="margin-bottom: 1.5rem; color: var(--text-secondary)">
              Import multiple entities at once by uploading a
              <strong>JSON, CSV, or Excel</strong> file, or pasting JSON data.
              Each entity should have: <code>type</code>, <code>name</code>,
              <code>description</code>, and optionally
              <code>configurations</code>, <code>relationships</code>.
            </p>

            <div class="form-group">
              <label class="form-label"
                >Upload File (JSON, CSV, or Excel)</label
              >
              <input
                type="file"
                id="bulk-file-input"
                accept=".json,.csv,.xlsx,.xls"
                class="form-input"
                onchange="handleBulkFileUpload(event)"
              />
              <small
                style="
                  color: var(--text-secondary);
                  margin-top: 0.25rem;
                  display: block;
                "
              >
                CSV/Excel Format:
                <code
                  >type, name, description, owner, region/version/sourceService,
                  endpoint/targetService, protocol, sourceEntity,
                  relationshipType, targetEntity, config_key1, config_value1,
                  config_key2, config_value2, ...</code
                >
              </small>
            </div>

            <div class="form-group">
              <div
                style="
                  display: flex;
                  justify-content: space-between;
                  align-items: center;
                  margin-bottom: 0.5rem;
                "
              >
                <label class="form-label" style="margin-bottom: 0"
                  >Or Paste JSON Data</label
                >
                <div style="display: flex; gap: 0.5rem">
                  <button
                    type="button"
                    class="btn btn-sm btn-secondary"
                    onclick="formatBulkJson()"
                  >
                    Format JSON
                  </button>
                  <button
                    type="button"
                    class="btn btn-sm btn-secondary"
                    onclick="validateBulkJson()"
                  >
                    Validate JSON
                  </button>
                  <button
                    type="button"
                    class="btn btn-sm btn-secondary"
                    onclick="clearBulkJson()"
                  >
                    Clear
                  </button>
                </div>
              </div>
              <textarea
                id="bulk-json-input"
                class="form-input"
                rows="15"
                placeholder='{
  "entities": [
    {
      "type": "Integration",
      "name": "MyIntegration",
      "description": "Description here",
      "sourceService": "",
      "targetService": "",
      "protocol": "",
      "owner": "",
      "configurations": {
        "key1": "value1",
        "key2": "value2"
      }
    }
  ]
}'
                style="
                  font-family: &quot;Courier New&quot;, monospace;
                  font-size: 0.85rem;
                "
              ></textarea>
            </div>

            <div id="bulk-preview" style="display: none; margin-bottom: 1.5rem">
              <h3
                style="font-size: 1rem; font-weight: 600; margin-bottom: 0.5rem"
              >
                Preview
              </h3>
              <div
                id="bulk-preview-content"
                style="
                  padding: 0.75rem;
                  background: var(--bg-tertiary);
                  border-radius: 0.375rem;
                  font-size: 0.875rem;
                "
              ></div>
            </div>

            <div class="btn-group">
              <button
                type="button"
                class="btn btn-primary"
                onclick="submitBulkImport()"
              >
                Import Entities
              </button>
            </div>

            <div id="bulk-results" style="margin-top: 1.5rem; display: none">
              <h3
                style="
                  font-size: 1rem;
                  font-weight: 600;
                  margin-bottom: 0.75rem;
                "
              >
                Import Results
              </h3>
              <div id="bulk-results-content"></div>
            </div>
          </div>
        </div>

        <!-- Admin Tab -->
        <div id="admin" class="tab-pane">
          <div class="card">
            <h2 class="card-title">System Administration</h2>

            <div class="btn-group" style="margin-bottom: 1rem">
              <button class="btn btn-primary" onclick="healthCheck()">
                Health Check
              </button>
              <button class="btn btn-secondary" onclick="getEntityCounts()">
                Entity Counts
              </button>
            </div>

            <div id="admin-results" class="query-result">
              <div class="loading">
                Click a button to see system information
              </div>
            </div>

            <div class="danger-zone">
              <h3 class="danger-zone-title">Danger Zone</h3>
              <p style="margin-bottom: 1rem; color: var(--text-secondary)">
                The following operations cannot be undone!
              </p>

              <button class="btn btn-danger" onclick="deleteAllEntities()">
                Delete All Data
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <!-- Edge Context Menu -->
    <div id="edge-context-menu" class="context-menu" style="display: none">
      <div class="context-menu-item" onclick="reverseRelationship()">
        Reverse Direction
      </div>
      <div
        class="context-menu-item context-menu-danger"
        onclick="deleteRelationship()"
      >
        Delete Relationship
      </div>
    </div>

    <!-- Confirmation Modal -->
    <div id="confirm-modal" class="modal-overlay" style="display: none">
      <div class="modal-content" style="max-width: 500px">
        <div
          class="modal-header"
          style="border-bottom: none; padding-bottom: 0"
        >
          <h2 id="confirm-modal-title" style="font-size: 1.25rem">
            Confirm Action
          </h2>
        </div>
        <div class="modal-body">
          <div
            id="confirm-modal-message"
            style="
              color: var(--text-secondary);
              line-height: 1.6;
              white-space: pre-wrap;
            "
          ></div>
        </div>
        <div
          style="
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
            margin-top: 1.5rem;
          "
        >
          <button id="confirm-modal-cancel" class="btn btn-secondary">
            Cancel
          </button>
          <button id="confirm-modal-ok" class="btn btn-primary">OK</button>
        </div>
      </div>
    </div>

    <!-- Edit Entity Modal -->
    <div id="edit-modal" class="modal-overlay" style="display: none">
      <div class="modal-content">
        <div class="modal-header">
          <h2>Edit Entity</h2>
          <button class="modal-close" onclick="closeEditModal()">×</button>
        </div>

        <div id="edit-alerts"></div>

        <form id="edit-entity-form" onsubmit="saveEntityEdit(event)">
          <input type="hidden" id="edit-entity-id" />
          <input type="hidden" id="edit-entity-type" />

          <div class="form-group">
            <label class="form-label">Entity Type</label>
            <div
              id="edit-entity-type-display"
              style="font-weight: 600; color: var(--primary-color)"
            ></div>
          </div>

          <div class="form-group">
            <label class="form-label" for="edit-entity-name">Name</label>
            <input
              type="text"
              id="edit-entity-name"
              class="form-input"
              required
            />
          </div>

          <div class="form-group">
            <label class="form-label" for="edit-entity-description"
              >Description</label
            >
            <textarea
              id="edit-entity-description"
              class="form-textarea"
              rows="3"
            ></textarea>
          </div>

          <div class="form-group">
            <label class="form-label" for="edit-entity-owner">Owner</label>
            <input type="text" id="edit-entity-owner" class="form-input" />
          </div>

          <div class="form-group">
            <label class="form-label" for="edit-entity-status">Status</label>
            <select id="edit-entity-status" class="form-select">
              <option value="active">Active</option>
              <option value="inactive">Inactive</option>
              <option value="deprecated">Deprecated</option>
            </select>
          </div>

          <!-- Environment specific fields -->
          <div id="edit-environment-fields" style="display: none">
            <div class="form-group">
              <label class="form-label" for="edit-env-region">Region</label>
              <input type="text" id="edit-env-region" class="form-input" />
            </div>
            <div class="form-group">
              <label class="form-label" for="edit-env-endpoint">Endpoint</label>
              <input type="url" id="edit-env-endpoint" class="form-input" />
            </div>
          </div>

          <!-- Application specific fields -->
          <div id="edit-application-fields" style="display: none">
            <div class="form-group">
              <label class="form-label" for="edit-app-version">Version</label>
              <input type="text" id="edit-app-version" class="form-input" />
            </div>
          </div>

          <!-- Integration specific fields -->
          <div id="edit-integration-fields" style="display: none">
            <div class="form-group">
              <label class="form-label" for="edit-int-protocol">Protocol</label>
              <select id="edit-int-protocol" class="form-select">
                <option value="">Select protocol</option>
                <option value="REST">REST</option>
                <option value="SOAP">SOAP</option>
                <option value="GraphQL">GraphQL</option>
                <option value="gRPC">gRPC</option>
              </select>
            </div>
            <div class="form-group">
              <label class="form-label" for="edit-int-source"
                >Source Service</label
              >
              <input type="text" id="edit-int-source" class="form-input" />
            </div>
            <div class="form-group">
              <label class="form-label" for="edit-int-target"
                >Target Service</label
              >
              <input type="text" id="edit-int-target" class="form-input" />
            </div>
          </div>

          <div class="form-group">
            <div
              style="
                display: flex;
                align-items: center;
                cursor: pointer;
                user-select: none;
                margin-bottom: 0.5rem;
              "
              onclick="toggleEditConfigSection()"
            >
              <span
                id="edit-config-toggle-icon"
                style="
                  margin-right: 0.5rem;
                  font-size: 0.75rem;
                  transition: transform 0.2s;
                "
                >&#9654;</span
              >
              <label
                class="form-label"
                style="margin-bottom: 0; cursor: pointer"
                >Custom Configuration</label
              >
            </div>
            <div id="edit-config-section" style="display: none">
              <div class="config-container">
                <div id="edit-config-list"></div>
                <div
                  style="
                    display: flex;
                    gap: 0.5rem;
                    flex-wrap: wrap;
                    align-items: center;
                  "
                >
                  <button
                    type="button"
                    class="btn btn-secondary btn-sm"
                    onclick="addEditConfigField()"
                  >
                    Add Configuration
                  </button>
                  <span style="color: var(--text-secondary); font-size: 0.75rem"
                    >or</span
                  >
                  <label
                    class="btn btn-secondary btn-sm"
                    style="cursor: pointer; margin: 0"
                  >
                    Upload CSV
                    <input
                      type="file"
                      id="edit-config-csv-input"
                      accept=".csv"
                      style="display: none"
                      onchange="handleEditConfigCsvUpload(event)"
                    />
                  </label>
                </div>
                <small
                  style="
                    color: var(--text-secondary);
                    margin-top: 0.5rem;
                    display: block;
                    font-size: 0.75rem;
                  "
                >
                  CSV format: <code>config_key, config_value</code> — one row
                  per entry
                </small>
                <div
                  id="edit-config-csv-preview"
                  style="display: none; margin-top: 0.5rem"
                >
                  <div
                    id="edit-config-csv-preview-content"
                    style="
                      max-height: 150px;
                      overflow-y: auto;
                      border: 1px solid var(--border-color);
                      border-radius: 0.375rem;
                      padding: 0.5rem;
                      background: var(--bg-primary);
                      font-size: 0.8rem;
                    "
                  ></div>
                </div>
              </div>
            </div>
          </div>

          <div class="btn-group" style="margin-top: 1.5rem">
            <button type="submit" class="btn btn-primary">Save Changes</button>
            <button
              type="button"
              class="btn btn-secondary"
              onclick="closeEditModal()"
            >
              Cancel
            </button>
          </div>
        </form>
      </div>
    </div>

    <script>
      // Configuration - Updated Lambda URLs from NeptuneEnvironmentStack
      const CONFIG = {
        INGEST_URL:
          "https://pavdiuem80.execute-api.us-east-1.amazonaws.com/prod/ingest",
        QUERY_URL:
          "https://pavdiuem80.execute-api.us-east-1.amazonaws.com/prod/query",
        CLEANUP_URL:
          "https://pavdiuem80.execute-api.us-east-1.amazonaws.com/prod/cleanup",
      };

      // Global state
      let networkData = { nodes: [], edges: [] };
      let simulation = null;
      let currentZoom = null;
      let allEntities = [];
      let connectionStatus = { ingest: false, query: false };
      let edgeLabelsVisible = true;

      // Initialize application
      document.addEventListener("DOMContentLoaded", function () {
        initializeTabs();
        initializeEntityForm();
        setupTooltipEvents();

        // Delayed connection check to avoid immediate failures
        setTimeout(() => {
          checkConnections();
        }, 1000);

        // Try to load entities after connection check
        setTimeout(() => {
          loadEntitiesForDeletion();
        }, 2000);

        // Initialize relationships tab after a delay to ensure API connection
        setTimeout(() => {
          initializeRelationshipsTab();
        }, 3000);

        // Populate all dropdowns after connection is established
        setTimeout(() => {
          populateAllDropdowns();
        }, 4000);
      });

      // Add retry functionality
      async function retryOperation(operation, maxRetries = 3) {
        for (let i = 0; i < maxRetries; i++) {
          try {
            return await operation();
          } catch (error) {
            if (i === maxRetries - 1) throw error;
            await new Promise((resolve) => setTimeout(resolve, 1000 * (i + 1))); // Exponential backoff
          }
        }
      }

      function initializeTabs() {
        const tabs = document.querySelectorAll(".nav-tab");
        const panes = document.querySelectorAll(".tab-pane");

        tabs.forEach((tab) => {
          tab.addEventListener("click", function () {
            const targetTab = this.dataset.tab;

            tabs.forEach((t) => t.classList.remove("active"));
            panes.forEach((p) => p.classList.remove("active"));

            this.classList.add("active");
            document.getElementById(targetTab).classList.add("active");

            // Refresh relationships dropdowns when switching to relationships tab
            if (targetTab === "relationships") {
              setTimeout(() => {
                initializeRelationshipsTab();
              }, 100);
            }

            // Auto-load graph data when switching to visualize tab
            if (targetTab === "visualize") {
              setTimeout(() => {
                loadNetworkData();
              }, 100);
            }
          });
        });

        // Function to programmatically switch tabs
        function switchToTab(targetTabId) {
          const tabs = document.querySelectorAll(".nav-tab");
          const panes = document.querySelectorAll(".tab-pane");

          // Remove active class from all tabs and panes
          tabs.forEach((t) => t.classList.remove("active"));
          panes.forEach((p) => p.classList.remove("active"));

          // Add active class to target tab and pane
          const targetTab = document.querySelector(
            `[data-tab="${targetTabId}"]`,
          );
          const targetPane = document.getElementById(targetTabId);

          if (targetTab) targetTab.classList.add("active");
          if (targetPane) targetPane.classList.add("active");

          // Refresh relationships dropdowns when switching to relationships tab
          if (targetTabId === "relationships") {
            setTimeout(() => {
              initializeRelationshipsTab();
            }, 100);
          }

          // Auto-load graph data when switching to visualize tab
          if (targetTabId === "visualize") {
            setTimeout(() => {
              loadNetworkData();
            }, 100);
          }
        }
      }

      function initializeEntityForm() {
        document
          .getElementById("entity-type")
          .addEventListener("change", async function () {
            const type = this.value;
            document.getElementById("environment-fields").style.display =
              type === "Environment" ? "block" : "none";
            document.getElementById("application-fields").style.display =
              type === "Application" ? "block" : "none";
            document.getElementById("integration-fields").style.display =
              type === "Integration" ? "block" : "none";

            // Load entities for integration dropdowns when Integration is selected
            if (type === "Integration") {
              await populateIntegrationDropdowns();
            }
          });

        document
          .getElementById("add-entity-form")
          .addEventListener("submit", createEntity);
      }

      // Populate integration source/target dropdowns with available entities
      async function populateIntegrationDropdowns() {
        console.log("Populating integration dropdowns...");

        try {
          const entities = await loadAvailableEntities();

          const sourceSelect = document.getElementById("int-source-service");
          const targetSelect = document.getElementById("int-target-service");

          if (!sourceSelect || !targetSelect) {
            console.error("Integration dropdown elements not found");
            return;
          }

          let options = '<option value="">Select service</option>';

          // Only include Environment and Application entities for integration dropdowns
          const serviceEntities = entities.filter(
            (entity) =>
              entity.type === "Environment" || entity.type === "Application",
          );

          serviceEntities.forEach((entity) => {
            options += `<option value="${entity.name}">${entity.name} (${entity.type})</option>`;
          });

          sourceSelect.innerHTML = options;
          targetSelect.innerHTML = options.replace(
            "Select service",
            "Select target service",
          );

          console.log(
            `Populated integration dropdowns with ${serviceEntities.length} services`,
          );
        } catch (error) {
          console.error("Error populating integration dropdowns:", error);
        }
      }

      // Populate all form dropdowns on page load
      async function populateAllDropdowns() {
        console.log("Populating all dropdowns on page load...");

        try {
          const entities = await loadAvailableEntities();

          // Populate relationship dropdowns
          populateEntityDropdowns(entities);

          // Populate integration dropdowns if integration fields are visible
          const integrationFields =
            document.getElementById("integration-fields");
          if (integrationFields && integrationFields.style.display !== "none") {
            await populateIntegrationDropdowns();
          }

          console.log("All dropdowns populated successfully");
        } catch (error) {
          console.error("Error populating dropdowns:", error);
        }
      }

      // Relationship management functions
      async function loadAvailableEntities() {
        console.log(
          "Loading available entities, connection status:",
          connectionStatus,
        );

        if (!connectionStatus.query) {
          console.log("No query connection, returning empty array");
          return [];
        }

        try {
          console.log("Making API call to get-entities...");
          const result = await makeApiCall(CONFIG.QUERY_URL, "get-entities");
          console.log("get-entities result:", result);

          if (result.success && result.data) {
            const allEntities = [];

            // Check if result.data has entities property
            if (result.data.entities) {
              console.log("Entities structure:", result.data.entities);

              // Handle both possible structures
              const entityData = result.data.entities;

              // Check for Environment/Application/Integration (uppercase)
              if (entityData.Environment) {
                console.log(
                  "Found Environment entities:",
                  entityData.Environment,
                );
                allEntities.push(
                  ...entityData.Environment.map((e) => ({
                    ...e,
                    type: "Environment",
                  })),
                );
              }
              if (entityData.Application) {
                console.log(
                  "Found Application entities:",
                  entityData.Application,
                );
                allEntities.push(
                  ...entityData.Application.map((e) => ({
                    ...e,
                    type: "Application",
                  })),
                );
              }
              if (entityData.Integration) {
                console.log(
                  "Found Integration entities:",
                  entityData.Integration,
                );
                allEntities.push(
                  ...entityData.Integration.map((e) => ({
                    ...e,
                    type: "Integration",
                  })),
                );
              }

              // Also check for lowercase plural versions
              if (entityData.environments) {
                console.log("Found environments:", entityData.environments);
                allEntities.push(
                  ...entityData.environments.map((e) => ({
                    ...e,
                    type: "Environment",
                  })),
                );
              }
              if (entityData.applications) {
                console.log("Found applications:", entityData.applications);
                allEntities.push(
                  ...entityData.applications.map((e) => ({
                    ...e,
                    type: "Application",
                  })),
                );
              }
              if (entityData.integrations) {
                console.log("Found integrations:", entityData.integrations);
                allEntities.push(
                  ...entityData.integrations.map((e) => ({
                    ...e,
                    type: "Integration",
                  })),
                );
              }
            }

            console.log("Total entities loaded:", allEntities);
            return allEntities;
          } else {
            console.log(
              "No entities found in result or result not successful:",
              result,
            );
          }
        } catch (error) {
          console.error("Failed to load entities:", error);
        }
        return [];
      }

      async function addRelationshipField() {
        const relationshipsContainer =
          document.getElementById("relationships-list");
        const relationshipId = "rel_" + Date.now();

        // Load available entities for dropdown
        const entities = await loadAvailableEntities();
        let entityOptions = '<option value="">Select target entity</option>';
        entities.forEach((entity) => {
          entityOptions += `<option value="${entity.name}" data-id="${entity.id}">${entity.name} (${entity.type})</option>`;
        });

        const relationshipHtml = `
          <div class="relationship-item" id="${relationshipId}">
            <select class="form-select relationship-type" required>
              <option value="">Select relationship</option>
              <option value="dependsOn">Depends On</option>
              <option value="integrates">Integrates With</option>
              <option value="deploysTo">Deploys To</option>
              <option value="configures">Configures</option>
              <option value="monitors">Monitors</option>
              <option value="connects">Connects To</option>
            </select>
            <select class="form-select relationship-target" required>
              ${entityOptions}
            </select>
            <button type="button" class="remove-relationship" 
                    onclick="removeRelationshipField('${relationshipId}')">×</button>
          </div>
        `;

        relationshipsContainer.insertAdjacentHTML(
          "beforeend",
          relationshipHtml,
        );
      }

      function removeRelationshipField(relationshipId) {
        const element = document.getElementById(relationshipId);
        if (element) {
          element.remove();
        }
      }

      function getRelationships() {
        const relationships = [];
        const relationshipItems =
          document.querySelectorAll(".relationship-item");

        relationshipItems.forEach((item) => {
          const type = item.querySelector(".relationship-type").value;
          const target = item.querySelector(".relationship-target").value;

          if (type && target) {
            relationships.push({
              type: type,
              target: target.trim(),
            });
          }
        });

        return relationships;
      }

      // Configuration management functions
      function addConfigField() {
        const configContainer = document.getElementById("config-list");
        const configId = "config_" + Date.now();

        const configHtml = `
          <div class="config-item" id="${configId}">
            <input type="text" class="form-input config-key" placeholder="Key" required />
            <input type="text" class="form-input config-value" placeholder="Value" required />
            <button type="button" class="remove-config" 
                    onclick="removeConfigField('${configId}')">×</button>
          </div>
        `;

        configContainer.insertAdjacentHTML("beforeend", configHtml);
      }

      function removeConfigField(configId) {
        const element = document.getElementById(configId);
        if (element) {
          element.remove();
        }
      }

      function getConfigurations() {
        const configurations = {};
        const configItems = document.querySelectorAll(".config-item");

        configItems.forEach((item) => {
          const key = item.querySelector(".config-key").value.trim();
          const value = item.querySelector(".config-value").value.trim();

          if (key && value) {
            configurations[key] = value;
          }
        });

        return configurations;
      }

      // Refresh entity dropdowns manually
      async function refreshEntityDropdowns() {
        console.log("Manual refresh of entity dropdowns requested");

        try {
          console.log("Starting entity refresh...");
          const entities = await loadAvailableEntities();

          console.log("Entities loaded, now populating dropdowns...");
          populateEntityDropdowns(entities);

          // Double-check dropdown population after load
          const sourceSelect = document.getElementById("source-entity");
          const targetSelect = document.getElementById("target-entity");

          console.log(
            "After refresh - Source dropdown options:",
            sourceSelect ? sourceSelect.options.length : "not found",
          );
          console.log(
            "After refresh - Target dropdown options:",
            targetSelect ? targetSelect.options.length : "not found",
          );

          if (entities && entities.length > 0) {
            if (
              sourceSelect &&
              targetSelect &&
              sourceSelect.options.length > 1
            ) {
              showAlert(
                "relationships-alerts",
                `Loaded ${entities.length} entities successfully - dropdowns populated`,
                "success",
              );
            } else {
              console.warn("Entities loaded but dropdowns still empty");
              showAlert(
                "relationships-alerts",
                `Loaded ${entities.length} entities but dropdowns not populated - check console`,
                "warning",
              );
            }
          } else {
            showAlert(
              "relationships-alerts",
              "No entities found. Try creating some entities first.",
              "info",
            );
          }
        } catch (error) {
          console.error("Error during refresh:", error);
          showAlert(
            "relationships-alerts",
            "Failed to refresh entities: " + error.message,
            "error",
          );
        }
      }

      // Initialize relationships tab
      async function initializeRelationshipsTab() {
        console.log("Initializing relationships tab...");

        // Load entities for dropdowns
        const entities = await loadAvailableEntities();
        console.log("Loaded entities:", entities);

        populateEntityDropdowns(entities);

        // Add form event listener (check if already added)
        const form = document.getElementById("create-relationship-form");
        if (form && !form.hasAttribute("data-listener-added")) {
          form.addEventListener("submit", createStandaloneRelationship);
          form.setAttribute("data-listener-added", "true");
        }
      }

      function populateEntityDropdowns(entities) {
        console.log("Populating entity dropdowns with:", entities);
        console.log("Entity count:", entities ? entities.length : 0);

        const sourceSelect = document.getElementById("source-entity");
        const targetSelect = document.getElementById("target-entity");

        if (!sourceSelect || !targetSelect) {
          console.error(
            "Could not find source-entity or target-entity select elements",
          );
          console.log("Available elements:", {
            sourceSelect: !!sourceSelect,
            targetSelect: !!targetSelect,
          });
          return;
        }

        let options = '<option value="">Select entity</option>';

        if (entities && entities.length > 0) {
          entities.forEach((entity, index) => {
            console.log(`Processing entity ${index}:`, entity);

            // Ensure we have required fields
            if (entity.id && entity.name) {
              options += `<option value="${entity.id}" data-name="${
                entity.name
              }">${entity.name} (${entity.type || "Unknown"})</option>`;
            } else {
              console.warn("Entity missing id or name:", entity);
            }
          });
        } else {
          console.log("No entities to populate or entities array is empty");
        }

        console.log("Final options HTML:", options);

        sourceSelect.innerHTML = options;
        targetSelect.innerHTML = options;

        // Force a refresh of the select elements
        sourceSelect.dispatchEvent(new Event("change"));
        targetSelect.dispatchEvent(new Event("change"));

        console.log(
          "Dropdowns populated. Source options count:",
          sourceSelect.options.length,
        );
        console.log("Target options count:", targetSelect.options.length);
        console.log("Source select HTML:", sourceSelect.innerHTML);
        console.log("Target select HTML:", targetSelect.innerHTML);

        // Populate searchable dropdowns for source and target entities
        const entityItems = (entities || [])
          .filter((e) => e.id && e.name)
          .map((e) => ({
            value: e.id,
            label: `${e.name} (${e.type || "Unknown"})`,
          }));
        initSearchableDropdown("source-entity", entityItems);
        initSearchableDropdown("target-entity", entityItems);

        // Populate searchable dropdown for relationship type
        const relTypeItems = [
          { value: "dependsOn", label: "Depends On" },
          { value: "integrates", label: "Integrates With" },
          { value: "deploysTo", label: "Deploys To" },
          { value: "configures", label: "Configures" },
          { value: "monitors", label: "Monitors" },
          { value: "connects", label: "Connects To" },
        ];
        initSearchableDropdown("rel-type", relTypeItems);
      }

      /**
       * Initialize a searchable dropdown for a given select element.
       * @param {string} selectId - The id of the hidden <select>
       * @param {Array<{value: string, label: string}>} items - The dropdown options
       */
      function initSearchableDropdown(selectId, items) {
        const searchInput = document.getElementById(selectId + "-search");
        const listContainer = document.getElementById(selectId + "-list");
        const hiddenSelect = document.getElementById(selectId);

        if (!searchInput || !listContainer || !hiddenSelect) return;

        // Store items on the element for filtering
        searchInput._items = items;
        searchInput._selectId = selectId;

        // Render all items initially
        renderDropdownOptions(selectId, items);

        // Remove previous listeners by cloning
        const newInput = searchInput.cloneNode(true);
        newInput._items = items;
        newInput._selectId = selectId;
        searchInput.parentNode.replaceChild(newInput, searchInput);

        // On focus, open the list
        newInput.addEventListener("focus", function () {
          const list = document.getElementById(selectId + "-list");
          list.classList.add("open");
          renderDropdownOptions(
            selectId,
            filterDropdownItems(selectId, this.value),
          );
        });

        // On input, filter the list
        newInput.addEventListener("input", function () {
          const list = document.getElementById(selectId + "-list");
          list.classList.add("open");
          renderDropdownOptions(
            selectId,
            filterDropdownItems(selectId, this.value),
          );
          // Clear selection if text doesn't match
          const sel = document.getElementById(selectId);
          const match = (newInput._items || []).find(
            (i) => i.label.toLowerCase() === this.value.toLowerCase(),
          );
          if (!match) {
            sel.value = "";
          }
        });

        // Close dropdown when clicking outside
        document.addEventListener("click", function (e) {
          const wrapper = document.getElementById(selectId + "-wrapper");
          if (wrapper && !wrapper.contains(e.target)) {
            const list = document.getElementById(selectId + "-list");
            if (list) list.classList.remove("open");
          }
        });
      }

      function filterDropdownItems(selectId, searchText) {
        const searchInput = document.getElementById(selectId + "-search");
        const items = searchInput._items || [];
        const term = (searchText || "").toLowerCase();
        if (!term) return items;
        return items.filter((item) => item.label.toLowerCase().includes(term));
      }

      function renderDropdownOptions(selectId, items) {
        const listContainer = document.getElementById(selectId + "-list");
        const hiddenSelect = document.getElementById(selectId);
        if (!listContainer) return;

        if (items.length === 0) {
          listContainer.innerHTML =
            '<div class="dropdown-no-results">No results found</div>';
          return;
        }

        listContainer.innerHTML = items
          .map(
            (item) =>
              `<div class="dropdown-option${hiddenSelect && hiddenSelect.value === item.value ? " selected" : ""}" data-value="${item.value}">${item.label}</div>`,
          )
          .join("");

        // Attach click handlers to each option
        listContainer.querySelectorAll(".dropdown-option").forEach((opt) => {
          opt.addEventListener("click", function () {
            const value = this.getAttribute("data-value");
            const label = this.textContent;
            const search = document.getElementById(selectId + "-search");
            const sel = document.getElementById(selectId);

            // Set search input display text
            if (search) search.value = label;
            // Set hidden select value
            if (sel) {
              // Ensure option exists in hidden select
              let option = sel.querySelector(`option[value="${value}"]`);
              if (!option) {
                option = document.createElement("option");
                option.value = value;
                option.textContent = label;
                sel.appendChild(option);
              }
              sel.value = value;
            }
            // Mark selected
            listContainer
              .querySelectorAll(".dropdown-option")
              .forEach((o) => o.classList.remove("selected"));
            this.classList.add("selected");
            // Close dropdown
            listContainer.classList.remove("open");
          });
        });
      }

      async function createStandaloneRelationship(event) {
        event.preventDefault();

        const sourceEntityId = document.getElementById("source-entity").value;
        const relationshipType = document.getElementById("rel-type").value;
        const targetEntityId = document.getElementById("target-entity").value;

        if (!sourceEntityId || !relationshipType || !targetEntityId) {
          showAlert(
            "relationships-alerts",
            "Please fill in all fields",
            "error",
          );
          return;
        }

        if (sourceEntityId === targetEntityId) {
          showAlert(
            "relationships-alerts",
            "Source and target entities cannot be the same",
            "error",
          );
          return;
        }

        try {
          showAlert("relationships-alerts", "Creating relationship...", "info");

          // Get entity names for the API call
          const sourceOption = document.querySelector(
            `#source-entity option[value="${sourceEntityId}"]`,
          );
          const targetOption = document.querySelector(
            `#target-entity option[value="${targetEntityId}"]`,
          );

          const sourceName = sourceOption.dataset.name;
          const targetName = targetOption.dataset.name;

          const result = await makeApiCall(
            CONFIG.INGEST_URL,
            "create-relationship",
            {
              sourceEntityName: sourceName,
              relationshipType: relationshipType,
              targetEntityName: targetName,
            },
          );

          if (result.success) {
            showAlert(
              "relationships-alerts",
              `Relationship "${relationshipType}" created between ${sourceName} and ${targetName}`,
              "success",
            );
            document.getElementById("create-relationship-form").reset();
            // Clear searchable dropdown inputs
            [
              "source-entity-search",
              "rel-type-search",
              "target-entity-search",
            ].forEach((id) => {
              const el = document.getElementById(id);
              if (el) el.value = "";
            });
            loadExistingRelationships();
          } else {
            showAlert(
              "relationships-alerts",
              `Failed to create relationship: ${
                result.error || "Unknown error"
              }`,
              "error",
            );
          }
        } catch (error) {
          showAlert(
            "relationships-alerts",
            `Error creating relationship: ${error.message}`,
            "error",
          );
        }
      }

      async function loadExistingRelationships() {
        const container = document.getElementById("existing-relationships");

        try {
          container.innerHTML =
            '<div class="loading"><div class="spinner"></div>Loading relationships...</div>';

          const result = await makeApiCall(CONFIG.QUERY_URL, "sparql-query", {
            query: `
              PREFIX env: <http://neptune.aws.com/envmgmt/ontology/>
              
              SELECT ?relationshipId ?relationshipName ?relationshipType ?sourceEntity ?targetEntity WHERE {
                ?relationship env:type "Relationship" .
                ?relationship env:id ?relationshipId .
                ?relationship env:name ?relationshipName .
                ?relationship env:relationshipType ?relationshipType .
                ?relationship env:sourceEntity ?sourceEntity .
                ?relationship env:targetEntity ?targetEntity .
              }
              ORDER BY ?sourceEntity ?targetEntity
            `,
          });

          if (
            result.success &&
            result.data &&
            result.data.results &&
            result.data.results.bindings
          ) {
            const relationships = result.data.results.bindings;

            if (relationships.length === 0) {
              container.innerHTML =
                '<div class="alert alert-info">No relationships found</div>';
              return;
            }

            let html = "";
            relationships.forEach((rel) => {
              const relationshipId = rel.relationshipId?.value || "";
              const relationshipType = rel.relationshipType?.value || "Unknown";
              const sourceEntity = rel.sourceEntity?.value || "Unknown";
              const targetEntity = rel.targetEntity?.value || "Unknown";

              html += `
                <div class="relationship-record">
                  <div class="relationship-info">
                    <div class="relationship-source">${sourceEntity}</div>
                    <div class="relationship-type">${relationshipType}</div>
                    <div class="relationship-target">${targetEntity}</div>
                  </div>
                  <button class="btn btn-danger btn-sm" onclick="deleteRelationshipEntity('${relationshipId}')">
                    Delete
                  </button>
                </div>
              `;
            });

            container.innerHTML = html;
          } else {
            container.innerHTML =
              '<div class="alert alert-error">Failed to load relationships</div>';
          }
        } catch (error) {
          container.innerHTML =
            '<div class="alert alert-error">Error loading relationships: ' +
            error.message +
            "</div>";
        }
      }

      async function deleteRelationship(sourceId, predicateUri, targetId) {
        if (!confirm("Are you sure you want to delete this relationship?")) {
          return;
        }

        try {
          const result = await makeApiCall(CONFIG.QUERY_URL, "sparql-update", {
            query: `
              DELETE DATA {
                <${sourceId}> <${predicateUri}> <${targetId}> .
              }
            `,
          });

          if (result.success) {
            showAlert(
              "relationships-alerts",
              "Relationship deleted successfully",
              "success",
            );
            loadExistingRelationships();
          } else {
            showAlert(
              "relationships-alerts",
              "Failed to delete relationship",
              "error",
            );
          }
        } catch (error) {
          showAlert(
            "relationships-alerts",
            "Error deleting relationship: " + error.message,
            "error",
          );
        }
      }

      async function deleteRelationshipEntity(relationshipId) {
        if (!confirm("Are you sure you want to delete this relationship?")) {
          return;
        }

        try {
          const result = await makeApiCall(CONFIG.QUERY_URL, "sparql-update", {
            query: `
              PREFIX env: <http://neptune.aws.com/envmgmt/ontology/>
              
              DELETE WHERE {
                ?relationship env:id "${relationshipId}" .
                ?relationship ?predicate ?object .
              }
            `,
          });

          if (result.success) {
            showAlert(
              "relationships-alerts",
              "Relationship deleted successfully",
              "success",
            );
            loadExistingRelationships();
          } else {
            showAlert(
              "relationships-alerts",
              "Failed to delete relationship",
              "error",
            );
          }
        } catch (error) {
          showAlert(
            "relationships-alerts",
            "Error deleting relationship: " + error.message,
            "error",
          );
        }
      }

      // Connection management
      async function checkConnections() {
        updateConnectionStatus("checking");
        console.log(
          "=== Testing Lambda Functions with Enhanced CORS Headers ===",
        );

        // Test the Lambda functions directly to see if CORS is working
        try {
          const testResults = await testDirectApi();

          if (testResults.query || testResults.ingest) {
            console.log(
              "CORS working! At least one Lambda function is accessible.",
            );
          } else {
            console.log("CORS issues persist. Using bypass mode.");
            // Fallback to bypass mode
            connectionStatus.query = true;
            connectionStatus.ingest = true;
            updateConnectionStatus("bypassed");
          }
        } catch (error) {
          console.error("Connection test failed:", error);
          // Fallback to bypass mode
          connectionStatus.query = true;
          connectionStatus.ingest = true;
          updateConnectionStatus("bypassed");
        }
      }

      async function fallbackConnectionCheck() {
        try {
          console.log("Attempting fallback connection check...");

          // Try a very simple query that should always work
          const response = await fetch(
            `${CONFIG.QUERY_URL}?operation=sparql-query`,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
              },
              body: JSON.stringify({
                query: "SELECT (1 as ?test) WHERE { }",
              }),
              mode: "cors",
            },
          );

          if (response.ok) {
            const result = await response.json();
            console.log("Fallback connection successful:", result);
            connectionStatus.query = true;
            // For ingest, we'll assume it works if we can reach the domain
            connectionStatus.ingest = true;
            updateConnectionStatus("connected");
          } else {
            console.log("Fallback connection failed - HTTP", response.status);
            updateConnectionStatus("disconnected");
          }
        } catch (error) {
          console.error("Fallback connection check failed:", error);

          // BYPASS MODE: Assume services work despite connection errors
          console.log(
            "Bypassing connection check - assuming services are available",
          );
          connectionStatus.query = true;
          connectionStatus.ingest = true;
          updateConnectionStatus("bypassed");

          // Show warning that we're in bypass mode
          const statusEl = document.getElementById("connection-status");
          const text = statusEl.querySelector("span");
          text.textContent =
            "Connection check bypassed - services assumed available";
        }
      }

      // Add debug logging
      function logConnectionDebug() {
        console.log("=== Connection Debug Info ===");
        console.log("Query URL:", CONFIG.QUERY_URL);
        console.log("Ingest URL:", CONFIG.INGEST_URL);
        console.log("Query Status:", connectionStatus.query);
        console.log("Ingest Status:", connectionStatus.ingest);
        console.log("User Agent:", navigator.userAgent);
        console.log("Location:", window.location.href);
      }

      // Simple test function for debugging
      async function testSingleConnection() {
        console.log("=== Testing Single Connection ===");
        try {
          console.log("Testing query Lambda...");
          const response = await fetch(`${CONFIG.QUERY_URL}?operation=health`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Accept: "application/json",
            },
            body: JSON.stringify({}),
            mode: "cors",
          });
          console.log("Response status:", response.status);
          console.log("Response ok:", response.ok);
          console.log("Response headers:", [...response.headers.entries()]);

          if (response.ok) {
            const data = await response.json();
            console.log("Response data:", data);
          } else {
            console.log("Response not ok, status text:", response.statusText);
          }
        } catch (error) {
          console.error("Fetch error:", error);
          console.error("Error name:", error.name);
          console.error("Error message:", error.message);
          console.error("Error stack:", error.stack);
        }
      }

      // Direct API test function to verify Lambda functions work
      async function testDirectApi() {
        console.log("=== Testing Direct API Calls ===");

        const statusEl = document.getElementById("connection-status");
        const text = statusEl.querySelector("span");

        // Update UI to show testing
        updateConnectionStatus("checking");
        text.textContent = "Testing Lambda API connections...";

        let queryWorks = false;
        let ingestWorks = false;

        // Test query API with a simple SPARQL query
        try {
          console.log("Testing query API with SPARQL query...");
          const result = await makeApiCall(CONFIG.QUERY_URL, "sparql-query", {
            query: "SELECT (1 as ?test) WHERE { } LIMIT 1",
          });
          console.log("Query API test successful:", result);
          queryWorks = true;
        } catch (error) {
          console.error("Query API test failed:", error);
        }

        // Test ingest API - simple health check
        try {
          console.log("Testing ingest API...");
          const result = await makeApiCall(CONFIG.INGEST_URL, "health");
          console.log("Ingest API test successful:", result);
          ingestWorks = true;
        } catch (error) {
          console.error("Ingest API test failed:", error);
        }

        // Update connection status based on results
        connectionStatus.query = queryWorks;
        connectionStatus.ingest = ingestWorks;

        if (queryWorks && ingestWorks) {
          updateConnectionStatus("connected");
        } else if (queryWorks || ingestWorks) {
          updateConnectionStatus("partial");
          text.textContent = `Partial connection: Query ${
            queryWorks ? "OK" : "FAIL"
          }, Ingest ${ingestWorks ? "OK" : "FAIL"}`;
        } else {
          updateConnectionStatus("disconnected");
          text.textContent =
            "All API tests failed - Check Lambda configuration";
        }

        return { query: queryWorks, ingest: ingestWorks };
      }
      function updateConnectionStatus(status) {
        const statusEl = document.getElementById("connection-status");
        const indicator = statusEl.querySelector(".status-indicator");
        const text = statusEl.querySelector("span");

        indicator.className = "status-indicator";

        switch (status) {
          case "connected":
            indicator.classList.add("status-connected");
            text.textContent = "Connected to Lambda functions";
            break;
          case "partial":
            indicator.classList.add("status-checking");
            text.textContent =
              "Partial connection - Some services may be unavailable";
            break;
          case "disconnected":
            indicator.classList.add("status-disconnected");
            text.textContent = "Connection failed - Working in offline mode";
            break;
          case "bypassed":
            indicator.classList.add("status-checking");
            text.textContent =
              "Connection check bypassed - services assumed available";
            break;
          case "checking":
            indicator.classList.add("status-checking");
            text.textContent = "Checking connection...";
            break;
        }
      }

      // Utility functions
      function showAlert(containerId, message, type = "info") {
        const container = document.getElementById(containerId);
        const alert = document.createElement("div");
        alert.className = `alert alert-${type}`;
        alert.textContent = message;
        container.innerHTML = "";
        container.appendChild(alert);

        setTimeout(() => {
          if (alert.parentNode) {
            alert.style.opacity = "0";
            setTimeout(() => {
              if (alert.parentNode) {
                container.removeChild(alert);
              }
            }, 300);
          }
        }, 5000);
      }

      async function makeApiCall(url, operation, data = {}) {
        console.log(`Making API call: ${operation} to ${url}`);
        console.log("Request data:", data);

        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 second timeout

          // For API Gateway, include operation in the request body
          const requestBody = {
            operation: operation,
            ...data,
          };

          console.log("Full request URL:", url);
          console.log("Request body:", requestBody);

          const response = await fetch(url, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Accept: "application/json",
            },
            body: JSON.stringify(requestBody),
            mode: "cors",
            signal: controller.signal,
          });

          clearTimeout(timeoutId);

          console.log(`API Response for ${operation}:`, {
            status: response.status,
            ok: response.ok,
            statusText: response.statusText,
            headers: Object.fromEntries(response.headers.entries()),
          });

          if (!response.ok) {
            const errorText = await response
              .text()
              .catch(() => "Unknown error");
            console.error(`API Error Response: ${errorText}`);
            throw new Error(
              `HTTP ${response.status}: ${response.statusText} - ${errorText}`,
            );
          }

          const result = await response.json();
          console.log(`API Success for ${operation}:`, result);
          return result;
        } catch (error) {
          console.error(`API call failed for ${operation}:`, error);

          if (error.name === "AbortError") {
            throw new Error(
              "Request timeout - Lambda function may be cold starting. Please try again.",
            );
          } else if (
            error.message.includes("Failed to fetch") ||
            error.message.includes("CORS")
          ) {
            throw new Error(
              "CORS or network error - Lambda function may not be properly configured for cross-origin requests.",
            );
          } else if (error.message.includes("NetworkError")) {
            throw new Error(
              "Network error - Please check your internet connection and Lambda URLs.",
            );
          } else {
            throw new Error(`API Error: ${error.message}`);
          }
        }
      }

      // Entity creation
      async function createEntity(event) {
        event.preventDefault();

        if (!connectionStatus.ingest) {
          showAlert(
            "add-alerts",
            "Cannot create entity: No connection to ingest service",
            "error",
          );
          return;
        }

        const type = document.getElementById("entity-type").value;
        const name = document.getElementById("entity-name").value;
        const description = document.getElementById("entity-description").value;

        let entityData = { name, description, type };

        // Add type-specific fields
        if (type === "Environment") {
          entityData.region = document.getElementById("env-region").value;
          entityData.endpoint = document.getElementById("env-endpoint").value;
          entityData.owner = document.getElementById("env-owner").value;
        } else if (type === "Application") {
          entityData.version = document.getElementById("app-version").value;
          entityData.owner = document.getElementById("app-owner").value;
        } else if (type === "Integration") {
          entityData.sourceService =
            document.getElementById("int-source-service").value;
          entityData.targetService =
            document.getElementById("int-target-service").value;
          entityData.protocol = document.getElementById("int-protocol").value;
          entityData.owner = document.getElementById("int-owner").value;
        }

        // Add custom configurations
        const configurations = getConfigurations();
        console.log("Configurations collected from form:", configurations);
        if (Object.keys(configurations).length > 0) {
          entityData.configurations = configurations;
          console.log(
            "Added configurations to entityData:",
            entityData.configurations,
          );
        }

        // Add relationships
        const relationships = getRelationships();
        if (relationships.length > 0) {
          entityData.relationships = relationships;
        }

        try {
          showAlert("add-alerts", "Creating entity...", "info");

          const operation = "create";
          console.log("Sending entity data to API:", entityData);
          const result = await makeApiCall(
            CONFIG.INGEST_URL,
            operation,
            entityData,
          );
          console.log("API response:", result);

          if (result.success) {
            showAlert(
              "add-alerts",
              `${type} "${name}" created successfully!`,
              "success",
            );
            document.getElementById("add-entity-form").reset();
            // Clear configuration fields
            document.getElementById("config-list").innerHTML = "";
            document
              .getElementById("entity-type")
              .dispatchEvent(new Event("change"));
            loadEntitiesForDeletion();
          } else {
            showAlert(
              "add-alerts",
              `Failed to create ${type}: ${result.error || "Unknown error"}`,
              "error",
            );
          }
        } catch (error) {
          showAlert(
            "add-alerts",
            `Error creating ${type}: ${error.message}`,
            "error",
          );
        }
      }

      // Query functions
      async function queryAllEntities() {
        const query = `
                PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
                PREFIX env: <http://neptune.aws.com/envmgmt/ontology/>
                
                SELECT ?entity ?type ?name
                WHERE {
                    ?entity rdf:type ?type ;
                            env:name ?name .
                    FILTER(STRSTARTS(STR(?type), "http://neptune.aws.com/envmgmt/ontology/"))
                }
                ORDER BY ?type ?name
            `;
        await executeQuery(query);
      }

      async function queryEnvironments() {
        const query = `
                PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
                PREFIX env: <http://neptune.aws.com/envmgmt/ontology/>
                
                SELECT ?entity ?name ?region ?owner ?status
                WHERE {
                    ?entity rdf:type env:Environment ;
                            env:name ?name .
                    OPTIONAL { ?entity env:region ?region }
                    OPTIONAL { ?entity env:owner ?owner }
                    OPTIONAL { ?entity env:status ?status }
                }
                ORDER BY ?name
            `;
        await executeQuery(query);
      }

      async function queryApplications() {
        const query = `
                PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
                PREFIX env: <http://neptune.aws.com/envmgmt/ontology/>
                
                SELECT ?entity ?name ?version ?owner ?status
                WHERE {
                    ?entity rdf:type env:Application ;
                            env:name ?name .
                    OPTIONAL { ?entity env:version ?version }
                    OPTIONAL { ?entity env:owner ?owner }
                    OPTIONAL { ?entity env:status ?status }
                }
                ORDER BY ?name
            `;
        await executeQuery(query);
      }

      async function queryIntegrations() {
        const query = `
                PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
                PREFIX env: <http://neptune.aws.com/envmgmt/ontology/>
                
                SELECT ?entity ?name ?protocol ?owner ?status
                WHERE {
                    ?entity rdf:type env:Integration ;
                            env:name ?name .
                    OPTIONAL { ?entity env:protocol ?protocol }
                    OPTIONAL { ?entity env:owner ?owner }
                    OPTIONAL { ?entity env:status ?status }
                }
                ORDER BY ?name
            `;
        await executeQuery(query);
      }

      async function executeCustomQuery() {
        const query = document.getElementById("custom-query").value;
        await executeQuery(query);
      }

      let currentQueryResults = null; // Store current query results for visualization

      async function executeQuery(query) {
        if (!connectionStatus.query) {
          document.getElementById("query-results").innerHTML =
            '<div class="alert alert-error">Cannot execute query: No connection to query service</div>';
          document.getElementById("query-actions").style.display = "none";
          currentQueryResults = null;
          return;
        }

        try {
          document.getElementById("query-results").innerHTML =
            '<div class="loading"><div class="spinner"></div>Executing query...</div>';
          document.getElementById("query-actions").style.display = "none";

          const result = await makeApiCall(CONFIG.QUERY_URL, "sparql-query", {
            query,
          });

          if (result.success && result.data && result.data.results) {
            const bindings = result.data.results.bindings;
            currentQueryResults = { bindings, query }; // Store for visualization

            let html = `<div style="margin-bottom: 1rem;"><strong>Results: ${bindings.length} rows</strong></div>`;

            if (bindings.length > 0) {
              const headers = Object.keys(bindings[0]);
              html += '<table class="query-table">';
              html += "<thead><tr>";
              headers.forEach((header) => {
                html += `<th>${header}</th>`;
              });
              html += "</tr></thead><tbody>";

              bindings.forEach((binding) => {
                html += "<tr>";
                headers.forEach((header) => {
                  const value = binding[header] ? binding[header].value : "";
                  const shortValue =
                    value.length > 60 ? value.substring(0, 60) + "..." : value;
                  html += `<td title="${value}">${shortValue}</td>`;
                });
                html += "</tr>";
              });
              html += "</tbody></table>";

              // Show action buttons when there are results
              document.getElementById("query-actions").style.display = "block";
            } else {
              html += '<div class="alert alert-info">No results found.</div>';
              currentQueryResults = null;
            }

            document.getElementById("query-results").innerHTML = html;
          } else {
            document.getElementById("query-results").innerHTML =
              `<div class="alert alert-error">Error: ${
                result.error || "Failed to execute query"
              }</div>`;
            document.getElementById("query-actions").style.display = "none";
            currentQueryResults = null;
          }
        } catch (error) {
          document.getElementById("query-results").innerHTML =
            `<div class="alert alert-error">Error: ${error.message}</div>`;
          document.getElementById("query-actions").style.display = "none";
          currentQueryResults = null;
        }
      }

      // Visualize query results as a graph
      function visualizeQueryResults() {
        if (!currentQueryResults || !currentQueryResults.bindings) {
          alert("No query results to visualize");
          return;
        }

        try {
          const graphData = convertQueryResultsToGraph(
            currentQueryResults.bindings,
          );

          if (graphData.nodes.length === 0) {
            alert(
              "No entities found in query results to visualize. Make sure your query includes entity URIs.",
            );
            return;
          }

          // Store the converted data as network data
          networkData = graphData;

          // Update stats
          document.getElementById("node-count").textContent =
            networkData.nodes.length;
          document.getElementById("edge-count").textContent =
            networkData.edges.length;

          // Switch to visualize tab and render graph
          const tabs = document.querySelectorAll(".nav-tab");
          const panes = document.querySelectorAll(".tab-pane");

          // Remove active class from all tabs and panes
          tabs.forEach((t) => t.classList.remove("active"));
          panes.forEach((p) => p.classList.remove("active"));

          // Add active class to visualize tab and pane
          const targetTab = document.querySelector(`[data-tab="visualize"]`);
          const targetPane = document.getElementById("visualize");

          if (targetTab) targetTab.classList.add("active");
          if (targetPane) targetPane.classList.add("active");

          renderGraph();

          // Show success message
          const alertDiv = document.createElement("div");
          alertDiv.className = "alert alert-success";
          alertDiv.style.position = "fixed";
          alertDiv.style.top = "20px";
          alertDiv.style.right = "20px";
          alertDiv.style.zIndex = "10000";
          alertDiv.innerHTML = `Graph generated with ${networkData.nodes.length} nodes and ${networkData.edges.length} edges`;
          document.body.appendChild(alertDiv);
          setTimeout(() => alertDiv.remove(), 3000);
        } catch (error) {
          console.error("Error visualizing query results:", error);
          alert("Error visualizing query results: " + error.message);
        }
      }

      // Convert SPARQL query results to graph format
      function convertQueryResultsToGraph(bindings) {
        const nodes = [];
        const edges = [];
        const nodeMap = new Map();
        const headers = Object.keys(bindings[0] || {});

        // Identify entity columns (typically URIs starting with http)
        const entityColumns = headers.filter((header) =>
          bindings.some((binding) => {
            const value = binding[header]?.value;
            return (
              value &&
              (value.startsWith("http://") || value.startsWith("https://"))
            );
          }),
        );

        // Process each result row
        bindings.forEach((binding, index) => {
          entityColumns.forEach((entityCol) => {
            const entityValue = binding[entityCol]?.value;
            if (!entityValue) return;

            // Extract entity ID from URI
            const entityId = entityValue.split("/").pop() || entityValue;

            if (!nodeMap.has(entityId)) {
              // Create node from entity
              const node = {
                id: entityId,
                name: entityId,
                label: entityId,
                type: "QueryResult",
                uri: entityValue,
              };

              // Add other properties from the same row
              headers.forEach((header) => {
                if (header !== entityCol && binding[header]?.value) {
                  const value = binding[header].value;
                  // Convert property name to camelCase
                  const propName = header.replace(/([A-Z])/g, (match, char) =>
                    char.toLowerCase(),
                  );
                  node[propName] = value;

                  // If it's a name or label field, use it as the display name
                  if (
                    header.toLowerCase().includes("name") ||
                    header.toLowerCase().includes("label")
                  ) {
                    node.name = value;
                    node.label = value;
                  }

                  // If it's a type field, use it as the node type
                  if (header.toLowerCase().includes("type")) {
                    node.type = value.split("/").pop() || value;
                  }
                }
              });

              nodeMap.set(entityId, node);
              nodes.push(node);
            }
          });
        });

        // Try to create edges from relationships found in the data
        bindings.forEach((binding) => {
          const entityCols = entityColumns.filter((col) => binding[col]?.value);

          // If we have multiple entities in the same row, create relationships
          if (entityCols.length >= 2) {
            const sourceId = binding[entityCols[0]].value.split("/").pop();
            const targetId = binding[entityCols[1]].value.split("/").pop();

            if (
              sourceId !== targetId &&
              nodeMap.has(sourceId) &&
              nodeMap.has(targetId)
            ) {
              // Look for relationship type in other columns
              let relationshipType = "related";
              const otherCols = headers.filter(
                (h) => !entityColumns.includes(h),
              );
              if (otherCols.length > 0) {
                const firstOtherCol = otherCols[0];
                relationshipType =
                  binding[firstOtherCol]?.value?.split("/").pop() ||
                  relationshipType;
              }

              edges.push({
                id: `${sourceId}-${targetId}-${edges.length}`,
                source: sourceId,
                target: targetId,
                type: relationshipType,
                label: relationshipType,
              });
            }
          }
        });

        return { nodes, edges };
      }

      // Export query results
      function exportQueryResults() {
        if (!currentQueryResults) {
          alert("No query results to export");
          return;
        }

        const dataStr = JSON.stringify(currentQueryResults, null, 2);
        const dataBlob = new Blob([dataStr], { type: "application/json" });
        const url = URL.createObjectURL(dataBlob);
        const link = document.createElement("a");
        link.href = url;
        link.download = `query-results-${
          new Date().toISOString().split("T")[0]
        }.json`;
        link.click();
        URL.revokeObjectURL(url);
      }

      // Graph visualization
      async function loadNetworkData() {
        if (!connectionStatus.query) {
          document.getElementById("node-count").textContent = "0";
          document.getElementById("edge-count").textContent = "0";
          return;
        }

        try {
          const result = await makeApiCall(CONFIG.QUERY_URL, "get-network");
          console.log("Network data API response:", result);

          if (result.success && result.data) {
            // Handle the nested structure: result.data.networkData
            networkData = result.data.networkData || result.data;
            console.log("Extracted network data:", networkData);
            console.log("Number of edges:", networkData.edges?.length);
            console.log(
              "Sample edges (first 3):",
              networkData.edges?.slice(0, 3),
            );

            // Log edges with relationshipId
            const edgesWithRelId = networkData.edges?.filter(
              (e) => e.relationshipId,
            );
            const edgesWithoutRelId = networkData.edges?.filter(
              (e) => !e.relationshipId,
            );
            console.log(`Edges WITH relationshipId: ${edgesWithRelId?.length}`);
            console.log(
              `Edges WITHOUT relationshipId: ${edgesWithoutRelId?.length}`,
            );
            if (edgesWithRelId?.length > 0) {
              console.log(
                "Sample edge with relationshipId:",
                edgesWithRelId[0],
              );
            }

            document.getElementById("node-count").textContent =
              networkData.nodes.length;
            document.getElementById("edge-count").textContent =
              networkData.edges.length;
            renderGraph();
          } else {
            console.error(
              "Failed to load network data:",
              result.error || "No data",
            );
          }
        } catch (error) {
          console.error("Error loading network data:", error);
        }
      }

      function renderGraph() {
        console.log("renderGraph called with networkData:", networkData);

        if (!networkData || !networkData.nodes || !networkData.edges) {
          console.error("Invalid networkData for rendering:", networkData);
          return;
        }

        console.log(
          "Nodes:",
          networkData.nodes.length,
          "Edges:",
          networkData.edges.length,
        );

        const container = document.querySelector(".graph-container");
        if (!container) {
          console.error("Graph container not found");
          return;
        }

        const svg = d3.select("#network-graph");
        if (svg.empty()) {
          console.error("SVG element #network-graph not found");
          return;
        }

        svg.selectAll("*").remove();

        const width = container.clientWidth;
        const height = container.clientHeight;

        console.log("Container dimensions:", width, "x", height);

        svg.attr("width", width).attr("height", height);

        const zoom = d3
          .zoom()
          .scaleExtent([0.1, 4])
          .on("zoom", (event) => {
            g.attr("transform", event.transform);
          });

        currentZoom = zoom;
        svg.call(zoom);

        // Define arrow markers for directional edges (multiple colors)
        const arrowColors = [
          { id: "arrow-green", color: "#059669" },
          { id: "arrow-red", color: "#dc2626" },
          { id: "arrow-blue", color: "#2563eb" },
          { id: "arrow-purple", color: "#7c3aed" },
          { id: "arrow-orange", color: "#ea580c" },
          { id: "arrow-cyan", color: "#0891b2" },
          { id: "arrow-gray", color: "#64748b" },
          { id: "arrow-default", color: "#94a3b8" },
        ];

        svg
          .append("defs")
          .selectAll("marker")
          .data(arrowColors)
          .enter()
          .append("marker")
          .attr("id", (d) => d.id)
          .attr("viewBox", "0 -3 6 6")
          .attr("refX", 18)
          .attr("refY", 0)
          .attr("markerWidth", 4)
          .attr("markerHeight", 4)
          .attr("orient", "auto")
          .append("path")
          .attr("d", "M0,-3L6,0L0,3")
          .attr("fill", (d) => d.color)
          .attr("stroke", (d) => d.color)
          .attr("stroke-width", 0.3);

        const g = svg.append("g");

        simulation = d3
          .forceSimulation(networkData.nodes)
          .force(
            "link",
            d3
              .forceLink(networkData.edges)
              .id((d) => d.id)
              .distance(120),
          )
          .force("charge", d3.forceManyBody().strength(-300))
          .force("center", d3.forceCenter(width / 2, height / 2))
          .force("collision", d3.forceCollide().radius(30));

        const link = g
          .append("g")
          .selectAll("line")
          .data(networkData.edges)
          .enter()
          .append("line")
          .attr("class", "link")
          .attr("marker-end", (d) => `url(#${getArrowMarkerID(d.type)})`)
          .attr("stroke", (d) => getEdgeColor(d.type))
          .attr("stroke-width", (d) => getEdgeWidth(d.type))
          .attr("stroke-dasharray", (d) => getEdgeDashArray(d.type))
          .style("cursor", "pointer")
          .on("contextmenu", (event, d) => {
            event.preventDefault();
            showEdgeContextMenu(event, d);
          })
          .on("mouseover", function () {
            d3.select(this).attr(
              "stroke-width",
              (d) => getEdgeWidth(d.type) * 2,
            );
          })
          .on("mouseout", function () {
            d3.select(this).attr("stroke-width", (d) => getEdgeWidth(d.type));
          });

        const node = g
          .append("g")
          .selectAll("circle")
          .data(networkData.nodes)
          .enter()
          .append("circle")
          .attr("class", "node")
          .attr("r", (d) => Math.sqrt((d.size || 10) * 2))
          .attr("fill", (d) => getNodeColor(d.type))
          .attr("stroke", (d) => d3.rgb(getNodeColor(d.type)).darker())
          .call(
            d3
              .drag()
              .on("start", dragstarted)
              .on("drag", dragged)
              .on("end", dragended),
          )
          .on("mouseover", showTooltip)
          .on("mouseout", hideTooltip);

        const labels = g
          .append("g")
          .selectAll("text")
          .data(networkData.nodes)
          .enter()
          .append("text")
          .attr("class", "node-label")
          .text((d) => d.label || d.name)
          .attr("dy", ".35em");

        // Add edge labels for relationships
        const edgeLabels = g
          .append("g")
          .selectAll("text")
          .data(networkData.edges)
          .enter()
          .append("text")
          .attr("class", "edge-label")
          .text((d) => d.label || d.type)
          .style("fill", (d) => getEdgeColor(d.type))
          .attr("dy", ".35em")
          .attr("text-anchor", "middle")
          .style("font-size", "12px")
          .style("fill", "#666")
          .style("background", "white")
          .style("padding", "2px")
          .style("cursor", "pointer")
          .style("opacity", edgeLabelsVisible ? 1 : 0) // Respect current visibility state
          .on("contextmenu", (event, d) => {
            event.preventDefault();
            showEdgeContextMenu(event, d);
          });

        simulation.on("tick", () => {
          link
            .attr("x1", (d) => d.source.x)
            .attr("y1", (d) => d.source.y)
            .attr("x2", (d) => d.target.x)
            .attr("y2", (d) => d.target.y);

          node.attr("cx", (d) => d.x).attr("cy", (d) => d.y);

          labels.attr("x", (d) => d.x).attr("y", (d) => d.y + 15);

          // Position edge labels in the middle of each edge
          edgeLabels
            .attr("x", (d) => (d.source.x + d.target.x) / 2)
            .attr("y", (d) => (d.source.y + d.target.y) / 2);
        });

        // Auto-fit graph to viewport once simulation stabilizes
        simulation.on("end", () => {
          fitGraphToViewport();
        });
      }

      function getNodeColor(type) {
        const colors = {
          Environment: "#059669",
          Application: "#2563eb",
          Integration: "#d97706",
        };
        return colors[type] || "#64748b";
      }

      function getEdgeColor(relationshipType) {
        const colors = {
          integrates: "#059669", // Green for integration relationships
          dependsOn: "#dc2626", // Red for dependency relationships
          connects: "#2563eb", // Blue for connection relationships
          deploysTo: "#7c3aed", // Purple for deployment relationships
          configures: "#ea580c", // Orange for configuration relationships
          monitors: "#0891b2", // Cyan for monitoring relationships
          sourceOf: "#64748b", // Gray for integration source relationships
          targetOf: "#64748b", // Gray for integration target relationships
        };
        return colors[relationshipType] || "#94a3b8";
      }

      function getEdgeWidth(relationshipType) {
        const widths = {
          integrates: 1.2, // Thinner for main integrations
          dependsOn: 1.0, // Thinner for dependencies
          connects: 0.8, // Thinner for connections
          deploysTo: 1.0, // Thinner for deployments
          configures: 0.8, // Thinner for configurations
          monitors: 0.6, // Very thin for monitoring
          sourceOf: 0.6, // Very thin for source relationships
          targetOf: 0.6, // Very thin for target relationships
        };
        return widths[relationshipType] || 0.8;
      }

      function getEdgeDashArray(relationshipType) {
        const patterns = {
          integrates: "none", // Solid line for integrations
          dependsOn: "5,5", // Dashed for dependencies
          connects: "none", // Solid for connections
          deploysTo: "10,2", // Long dashes for deployments
          configures: "3,3", // Small dashes for configurations
          monitors: "2,2", // Dotted for monitoring
          sourceOf: "none", // Solid for source
          targetOf: "none", // Solid for target
        };
        return patterns[relationshipType] || "none";
      }

      function getArrowMarkerID(relationshipType) {
        const markerMap = {
          integrates: "arrow-green",
          dependsOn: "arrow-red",
          connects: "arrow-blue",
          deploysTo: "arrow-purple",
          configures: "arrow-orange",
          monitors: "arrow-cyan",
          sourceOf: "arrow-gray",
          targetOf: "arrow-gray",
        };
        return markerMap[relationshipType] || "arrow-default";
      }

      function dragstarted(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
      }

      function dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;
      }

      function dragended(event, d) {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
      }

      function showTooltip(event, d) {
        const tooltip = document.getElementById("tooltip");
        tooltip.style.opacity = 1;
        tooltip.style.left = event.pageX + 10 + "px";
        tooltip.style.top = event.pageY - 10 + "px";

        // Debug logging to see what data we have
        console.log("Tooltip data for node:", d);
        console.log("Configurations property:", d.configurations);
        console.log(
          "Config_ properties:",
          Object.keys(d).filter((k) => k.startsWith("config_")),
        );
        console.log("All node properties:", Object.keys(d));

        // Build table-based tooltip
        let tooltipContent = `
          <div style="font-weight: 600; margin-bottom: 8px; color: #e2e8f0;">
            ${d.label || d.name || d.id}
          </div>
          <div style="color: #94a3b8; font-size: 0.8rem; margin-bottom: 10px;">
            ${d.type || "Unknown"}
          </div>
        `;

        // Collect all properties excluding internal D3 properties and config_ properties
        const excludeProps = [
          "label",
          "name",
          "type",
          "id",
          "x",
          "y",
          "vx",
          "vy",
          "fx",
          "fy",
          "index",
          "size",
          "configurations",
          "properties",
          "status",
          "owner",
        ];

        const properties = Object.keys(d).filter(
          (key) =>
            !excludeProps.includes(key) &&
            !key.startsWith("config_") &&
            d[key] !== null &&
            d[key] !== undefined &&
            d[key] !== "" &&
            typeof d[key] !== "object", // Exclude nested objects
        );

        // Create properties table if there are any properties
        if (properties.length > 0) {
          tooltipContent += `
            <table style="width: 100%; border-collapse: collapse; margin-bottom: 10px;">
              <thead>
                <tr>
                  <th style="background: #1e293b; color: #94a3b8; padding: 4px 8px; text-align: left; font-size: 0.75rem; border-bottom: 1px solid #334155;">Property</th>
                  <th style="background: #1e293b; color: #94a3b8; padding: 4px 8px; text-align: left; font-size: 0.75rem; border-bottom: 1px solid #334155;">Value</th>
                </tr>
              </thead>
              <tbody>
          `;

          properties.forEach((prop) => {
            const value = d[prop];

            // Clean up property name - remove URI prefixes and format nicely
            let cleanPropName = prop;
            if (prop.includes("#")) {
              cleanPropName = prop.split("#").pop();
            } else if (prop.includes("/")) {
              cleanPropName = prop.split("/").pop();
            }

            // Convert camelCase to Title Case
            const formattedProp = cleanPropName
              .replace(/([A-Z])/g, " $1")
              .replace(/^./, (str) => str.toUpperCase())
              .replace(/_/g, " ");

            // Handle different value types
            let displayValue;
            if (typeof value === "object") {
              if (Array.isArray(value)) {
                displayValue =
                  value.length > 0 ? `[${value.join(", ")}]` : "[]";
              } else {
                const objEntries = Object.entries(value)
                  .filter(([k, v]) => v !== null && v !== undefined && v !== "")
                  .map(([k, v]) => `${k}: ${v}`)
                  .slice(0, 3);
                displayValue =
                  objEntries.length > 0 ? `{${objEntries.join(", ")}}` : "{}";
                if (Object.keys(value).length > 3) {
                  displayValue += "...";
                }
              }
            } else {
              displayValue = String(value);
            }

            // Truncate very long values
            if (displayValue.length > 60) {
              displayValue = displayValue.substring(0, 60) + "...";
            }

            tooltipContent += `
              <tr>
                <td style="padding: 3px 8px; border-bottom: 1px solid #1e293b; color: #94a3b8; font-size: 0.75rem; font-weight: 500;">${formattedProp}</td>
                <td style="padding: 3px 8px; border-bottom: 1px solid #1e293b; color: #cbd5e1; font-size: 0.75rem;">${displayValue}</td>
              </tr>
            `;
          });

          tooltipContent += `
              </tbody>
            </table>
          `;
        }

        // Create configurations table - look for config_ properties directly on the node
        let configurationsData = null;

        // Look for properties that start with "config_"
        const configProps = Object.keys(d).filter(
          (key) =>
            key.startsWith("config_") &&
            d[key] &&
            d[key] !== null &&
            d[key] !== undefined &&
            d[key] !== "",
        );

        if (configProps.length > 0) {
          configurationsData = {};
          configProps.forEach((prop) => {
            // Remove the config_ prefix for display
            const displayKey = prop.replace("config_", "");
            configurationsData[displayKey] = d[prop];
          });
        }

        // Also check if there's a separate configurations object (fallback)
        if (
          !configurationsData &&
          d.configurations &&
          typeof d.configurations === "object" &&
          Object.keys(d.configurations).length > 0
        ) {
          configurationsData = d.configurations;
        }

        if (
          configurationsData &&
          typeof configurationsData === "object" &&
          Object.keys(configurationsData).length > 0
        ) {
          const configCount = Object.keys(configurationsData).length;
          tooltipContent += `
            <div style="color: #94a3b8; font-weight: 600; font-size: 0.8rem; margin-bottom: 5px; cursor: pointer;" onclick="toggleConfigDetails()">
              Custom Configuration (${configCount}) [Show]
            </div>
            <div id="config-details" style="display: none;">
            <table style="width: 100%; border-collapse: collapse; margin-bottom: 10px;">
              <thead>
                <tr>
                  <th style="background: #1e293b; color: #64748b; padding: 4px 8px; text-align: left; font-size: 0.75rem; border-bottom: 1px solid #334155;">Config Key</th>
                  <th style="background: #1e293b; color: #64748b; padding: 4px 8px; text-align: left; font-size: 0.75rem; border-bottom: 1px solid #334155;">Value</th>
                </tr>
              </thead>
              <tbody>
          `;

          Object.entries(configurationsData).forEach(([key, value]) => {
            if (value !== null && value !== undefined && value !== "") {
              let displayValue = String(value);
              if (displayValue.length > 50) {
                displayValue = displayValue.substring(0, 50) + "...";
              }

              tooltipContent += `
                <tr>
                  <td style="padding: 3px 8px; border-bottom: 1px solid #1e293b; color: #94a3b8; font-size: 0.75rem; font-weight: 500;">${key}</td>
                  <td style="padding: 3px 8px; border-bottom: 1px solid #1e293b; color: #cbd5e1; font-size: 0.75rem;">${displayValue}</td>
                </tr>
              `;
            }
          });

          tooltipContent += `
              </tbody>
            </table>
            </div>
          `;
        }

        // Add download button and entity ID at the bottom
        tooltipContent += `
          <div style="margin-top: 10px; padding-top: 8px; border-top: 1px solid #1e293b; text-align: center;">
            <button 
              onclick="downloadNodeProperties('${d.id}')" 
              style="
                background: #334155;
                color: #cbd5e1;
                border: 1px solid #475569;
                padding: 6px 12px;
                border-radius: 4px;
                font-size: 0.7rem;
                cursor: pointer;
                margin-bottom: 6px;
                transition: all 0.2s;
              "
              onmouseover="this.style.background='#475569'; this.style.color='#e2e8f0';"
              onmouseout="this.style.background='#334155'; this.style.color='#cbd5e1';"
            >
              Download Properties
            </button>
            <div style="color: #475569; font-size: 0.65rem;">
              Entity ID: ${d.id}
            </div>
          </div>
        `;

        tooltip.innerHTML = tooltipContent;

        // Fetch and display history asynchronously
        fetchAndDisplayHistory(d.id);
      }

      async function fetchAndDisplayHistory(entityId) {
        try {
          const result = await makeApiCall(
            CONFIG.QUERY_URL,
            "get-entity-history",
            { entityId },
          );

          if (
            result.success &&
            result.data &&
            result.data.history &&
            result.data.history.length > 0
          ) {
            const tooltip = document.getElementById("tooltip");
            const history = result.data.history;

            // Create history section HTML
            let historyHtml = `
              <div style="margin-top: 16px; padding-top: 12px; border-top: 1px solid #1e293b;">
                <div style="color: #94a3b8; font-weight: 600; font-size: 0.8rem; margin-bottom: 8px; cursor: pointer;" onclick="toggleHistoryDetails()">
                  Change History (${history.length}) [Show]
                </div>
                <div id="history-details" style="display: none; max-height: 200px; overflow-y: auto;">
                  <table style="width: 100%; border-collapse: collapse;">
                    <thead>
                      <tr>
                        <th style="background: #1e293b; color: #64748b; padding: 4px 8px; text-align: left; font-size: 0.7rem;">Action</th>
                        <th style="background: #1e293b; color: #64748b; padding: 4px 8px; text-align: left; font-size: 0.7rem;">When</th>
                      </tr>
                    </thead>
                    <tbody>
            `;

            history.forEach((event) => {
              const date = new Date(event.timestamp);
              const timeAgo = getTimeAgo(date);

              historyHtml += `
                <tr>
                  <td style="padding: 4px 8px; font-size: 0.7rem; color: #cbd5e1; border-bottom: 1px solid #1e293b;">
                    ${event.action}
                  </td>
                  <td style="padding: 4px 8px; font-size: 0.7rem; color: #94a3b8; border-bottom: 1px solid #1e293b;">
                    ${timeAgo}
                  </td>
                </tr>
              `;

              // Add changes details if available
              if (event.changes && typeof event.changes === "object") {
                const changesStr = JSON.stringify(event.changes, null, 2)
                  .replace(/"/g, "")
                  .replace(/[{}]/g, "")
                  .trim();
                if (changesStr) {
                  historyHtml += `
                    <tr>
                      <td colspan="2" style="padding: 4px 8px 8px 24px; font-size: 0.65rem; color: #64748b; font-style: italic; border-bottom: 1px solid #1e293b;">
                        ${changesStr}
                      </td>
                    </tr>
                  `;
                }
              }
            });

            historyHtml += `
                    </tbody>
                  </table>
                </div>
              </div>
            `;

            // Append history to tooltip
            tooltip.innerHTML += historyHtml;
          }
        } catch (error) {
          console.error("Error fetching history:", error);
        }
      }

      function toggleCreateConfigSection() {
        const section = document.getElementById("create-config-section");
        const icon = document.getElementById("create-config-toggle-icon");
        if (section.style.display === "none") {
          section.style.display = "block";
          icon.style.transform = "rotate(90deg)";
        } else {
          section.style.display = "none";
          icon.style.transform = "rotate(0deg)";
        }
      }

      function toggleEditConfigSection() {
        const section = document.getElementById("edit-config-section");
        const icon = document.getElementById("edit-config-toggle-icon");
        if (section.style.display === "none") {
          section.style.display = "block";
          icon.style.transform = "rotate(90deg)";
        } else {
          section.style.display = "none";
          icon.style.transform = "rotate(0deg)";
        }
      }

      function toggleHistoryDetails() {
        const details = document.getElementById("history-details");
        const header = details.previousElementSibling;
        if (details.style.display === "none") {
          details.style.display = "block";
          header.innerHTML = header.innerHTML.replace("[Show]", "[Hide]");
        } else {
          details.style.display = "none";
          header.innerHTML = header.innerHTML.replace("[Hide]", "[Show]");
        }
      }

      function getTimeAgo(date) {
        const seconds = Math.floor((new Date() - date) / 1000);
        const intervals = {
          year: 31536000,
          month: 2592000,
          week: 604800,
          day: 86400,
          hour: 3600,
          minute: 60,
        };

        for (const [unit, secondsInUnit] of Object.entries(intervals)) {
          const interval = Math.floor(seconds / secondsInUnit);
          if (interval >= 1) {
            return `${interval} ${unit}${interval > 1 ? "s" : ""} ago`;
          }
        }
        return "just now";
      }

      function downloadNodeProperties(nodeId) {
        // Find the node data by ID
        const node = networkData?.nodes?.find((n) => n.id === nodeId);
        if (!node) {
          alert("Node data not found");
          return;
        }

        // Create clean properties and configurations by processing all node keys
        const excludeProps = [
          "x",
          "y",
          "vx",
          "vy",
          "fx",
          "fy",
          "index",
          "size",
        ];
        const cleanProperties = {};
        const extractedConfigurations = {};

        Object.keys(node).forEach((key) => {
          if (!excludeProps.includes(key)) {
            const value = node[key];

            // Clean up property name - remove URI prefixes
            let cleanKey = key;
            if (key.includes("#")) {
              cleanKey = key.split("#").pop();
            } else if (key.includes("/")) {
              cleanKey = key.split("/").pop();
            }

            // Check if this is a configuration property
            if (cleanKey.startsWith("config_")) {
              // Extract configuration key and convert to readable format
              const configKey = cleanKey
                .substring(7)
                .replace(/_/g, " ")
                .replace(/\b\w/g, (l) => l.toUpperCase());
              extractedConfigurations[configKey] = value;
            } else {
              // Skip duplicate URI-based properties if we already have the clean version
              const hasCleanVersion =
                Object.keys(cleanProperties).includes(cleanKey);
              if (!hasCleanVersion || !key.includes("http://")) {
                // Convert property name to readable format
                const formattedKey = cleanKey
                  .replace(/([A-Z])/g, " $1")
                  .replace(/^./, (str) => str.toUpperCase())
                  .replace(/_/g, " ")
                  .trim();

                cleanProperties[formattedKey] = value;
              }
            }
          }
        });

        // Use existing configurations from node if available, otherwise use extracted ones
        const finalConfigurations =
          node.configurations && Object.keys(node.configurations).length > 0
            ? node.configurations
            : extractedConfigurations;

        // Create formatted data with metadata
        const downloadData = {
          entityInfo: {
            name: node.label || node.name || node.id,
            type: node.type || "Unknown",
            id: node.id,
            downloadedAt: new Date().toISOString(),
            downloadedBy: "Environment Management System",
          },
          properties: cleanProperties,
          configurations: finalConfigurations,
          summary: {
            totalProperties: Object.keys(cleanProperties).length,
            hasConfigurations: Object.keys(finalConfigurations).length > 0,
            configurationCount: Object.keys(finalConfigurations).length,
          },
        };

        // Convert to JSON string with pretty formatting
        const jsonString = JSON.stringify(downloadData, null, 2);

        // Create blob and download
        const blob = new Blob([jsonString], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");

        // Create filename with entity name and timestamp
        const entityName = (node.label || node.name || node.id).replace(
          /[^a-zA-Z0-9]/g,
          "_",
        );
        const timestamp = new Date().toISOString().split("T")[0];
        const filename = `${entityName}_properties_${timestamp}.json`;

        link.href = url;
        link.download = filename;
        link.click();

        // Clean up
        URL.revokeObjectURL(url);

        // Hide tooltip after download
        hideTooltip();

        // Show success message
        const alertDiv = document.createElement("div");
        alertDiv.style.position = "fixed";
        alertDiv.style.top = "20px";
        alertDiv.style.right = "20px";
        alertDiv.style.background = "linear-gradient(135deg, #10b981, #059669)";
        alertDiv.style.color = "white";
        alertDiv.style.padding = "12px 16px";
        alertDiv.style.borderRadius = "8px";
        alertDiv.style.boxShadow = "0 4px 6px rgba(0, 0, 0, 0.1)";
        alertDiv.style.zIndex = "10001";
        alertDiv.style.fontSize = "0.9rem";
        alertDiv.style.fontWeight = "500";
        alertDiv.innerHTML = `Downloaded: ${filename}`;

        document.body.appendChild(alertDiv);
        setTimeout(() => alertDiv.remove(), 3000);
      }

      let tooltipTimeout;

      function hideTooltip() {
        // Add a small delay to allow moving to tooltip
        tooltipTimeout = setTimeout(() => {
          document.getElementById("tooltip").style.opacity = 0;
        }, 100);
      }

      function keepTooltipVisible() {
        clearTimeout(tooltipTimeout);
      }

      // Edge context menu management
      let selectedEdge = null;

      function showEdgeContextMenu(event, edge) {
        console.log("Edge context menu for:", edge);
        console.log("Edge relationshipId:", edge.relationshipId);
        console.log("Edge has relationshipId?", !!edge.relationshipId);

        // Only show context menu for relationship entities (those with relationshipId)
        if (!edge.relationshipId) {
          console.log(
            "Edge has no relationshipId - cannot reverse/delete direct predicate relationships",
          );
          console.log(
            "This is likely a direct predicate relationship (hasApplication, hasIntegration, etc.)",
          );
          return;
        }

        selectedEdge = edge;
        console.log("Selected edge set to:", selectedEdge);

        const menu = document.getElementById("edge-context-menu");
        menu.style.display = "block";
        menu.style.left = event.pageX + "px";
        menu.style.top = event.pageY + "px";
        console.log("Context menu displayed at:", event.pageX, event.pageY);
      }

      function hideEdgeContextMenu() {
        const menu = document.getElementById("edge-context-menu");
        menu.style.display = "none";
        selectedEdge = null;
      }

      function showToastNotification(message, type = "info") {
        const toast = document.createElement("div");
        toast.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          padding: 16px 24px;
          background: ${type === "success" ? "#10b981" : type === "error" ? "#ef4444" : "#3b82f6"};
          color: white;
          border-radius: 8px;
          box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
          z-index: 10000;
          font-size: 14px;
          font-weight: 500;
          max-width: 350px;
          animation: slideIn 0.3s ease;
        `;
        toast.textContent = message;
        document.body.appendChild(toast);

        setTimeout(() => {
          toast.style.opacity = "0";
          toast.style.transition = "opacity 0.3s";
          setTimeout(() => {
            if (toast.parentNode) {
              document.body.removeChild(toast);
            }
          }, 300);
        }, 5000);
      }

      function showConfirmDialog(title, message, isDanger = false) {
        return new Promise((resolve) => {
          const modal = document.getElementById("confirm-modal");
          const titleEl = document.getElementById("confirm-modal-title");
          const messageEl = document.getElementById("confirm-modal-message");
          const okBtn = document.getElementById("confirm-modal-ok");
          const cancelBtn = document.getElementById("confirm-modal-cancel");

          titleEl.textContent = title;
          messageEl.textContent = message;

          // Style OK button based on action type
          if (isDanger) {
            okBtn.className = "btn btn-danger";
          } else {
            okBtn.className = "btn btn-primary";
          }

          modal.style.display = "block";

          const handleOk = () => {
            modal.style.display = "none";
            okBtn.removeEventListener("click", handleOk);
            cancelBtn.removeEventListener("click", handleCancel);
            document.removeEventListener("keydown", handleKeydown);
            resolve(true);
          };

          const handleCancel = () => {
            modal.style.display = "none";
            okBtn.removeEventListener("click", handleOk);
            cancelBtn.removeEventListener("click", handleCancel);
            document.removeEventListener("keydown", handleKeydown);
            resolve(false);
          };

          const handleKeydown = (e) => {
            if (e.key === "Escape") {
              handleCancel();
            } else if (e.key === "Enter") {
              handleOk();
            }
          };

          okBtn.addEventListener("click", handleOk);
          cancelBtn.addEventListener("click", handleCancel);
          document.addEventListener("keydown", handleKeydown);
        });
      }

      async function reverseRelationship() {
        console.log("=== reverseRelationship called ===");
        console.log("selectedEdge:", selectedEdge);

        if (!selectedEdge || !selectedEdge.relationshipId) {
          console.log(
            "ERROR: No relationship selected or missing relationship ID",
          );
          await showConfirmDialog(
            "Error",
            "No relationship selected or missing relationship ID",
          );
          hideEdgeContextMenu();
          return;
        }

        const sourceName =
          selectedEdge.source?.label || selectedEdge.source?.id || "Unknown";
        const targetName =
          selectedEdge.target?.label || selectedEdge.target?.id || "Unknown";
        const relationshipType =
          selectedEdge.label || selectedEdge.type || "relationship";

        console.log("Relationship details:", {
          sourceName,
          targetName,
          relationshipType,
        });

        const confirmed = await showConfirmDialog(
          "Reverse Relationship Direction",
          `Reverse the direction of this relationship?\n\n${sourceName} → ${targetName}\n(${relationshipType})\n\nwill become\n\n${targetName} → ${sourceName}\n(${relationshipType})`,
        );

        console.log("User confirmed:", confirmed);

        if (!confirmed) {
          hideEdgeContextMenu();
          return;
        }

        try {
          console.log(
            "Reversing relationship with ID:",
            selectedEdge.relationshipId,
          );
          const result = await makeApiCall(
            CONFIG.INGEST_URL,
            "reverse-relationship",
            { relationshipId: selectedEdge.relationshipId },
          );
          console.log("Reverse relationship result:", result);

          if (result.success) {
            showToastNotification(
              "Relationship direction reversed successfully",
              "success",
            );
            // Reload the graph to show the updated relationship
            await loadNetworkData();
          } else {
            showToastNotification(
              "Failed to reverse relationship: " +
                (result.error || "Unknown error"),
              "error",
            );
          }
        } catch (error) {
          console.error("Error reversing relationship:", error);
          showToastNotification(
            "Error reversing relationship: " + error.message,
            "error",
          );
        } finally {
          hideEdgeContextMenu();
        }
      }

      async function deleteRelationship() {
        console.log("=== deleteRelationship called ===");
        console.log("selectedEdge:", selectedEdge);

        if (!selectedEdge || !selectedEdge.relationshipId) {
          console.log(
            "ERROR: No relationship selected or missing relationship ID",
          );
          await showConfirmDialog(
            "Error",
            "No relationship selected or missing relationship ID",
          );
          hideEdgeContextMenu();
          return;
        }

        const sourceName =
          selectedEdge.source?.label || selectedEdge.source?.id || "Unknown";
        const targetName =
          selectedEdge.target?.label || selectedEdge.target?.id || "Unknown";
        const relationshipType =
          selectedEdge.label || selectedEdge.type || "relationship";

        console.log("Relationship details:", {
          sourceName,
          targetName,
          relationshipType,
        });

        const confirmed = await showConfirmDialog(
          "Delete Relationship",
          `Are you sure you want to delete this relationship?\n\n${sourceName} → ${targetName}\n(${relationshipType})\n\nThis action cannot be undone.`,
          true, // isDanger
        );

        console.log("User confirmed:", confirmed);

        if (!confirmed) {
          hideEdgeContextMenu();
          return;
        }

        try {
          console.log(
            "Deleting relationship with ID:",
            selectedEdge.relationshipId,
          );
          const result = await makeApiCall(
            CONFIG.INGEST_URL,
            "delete-relationship",
            { relationshipId: selectedEdge.relationshipId },
          );
          console.log("Delete relationship result:", result);

          if (result.success) {
            showToastNotification(
              "Relationship deleted successfully",
              "success",
            );
            // Reload the graph to show the updated network
            await loadNetworkData();
          } else {
            showToastNotification(
              "Failed to delete relationship: " +
                (result.error || "Unknown error"),
              "error",
            );
          }
        } catch (error) {
          console.error("Error deleting relationship:", error);
          showToastNotification(
            "Error deleting relationship: " + error.message,
            "error",
          );
        } finally {
          hideEdgeContextMenu();
        }
      }

      // Hide context menu when clicking anywhere else
      document.addEventListener("click", (event) => {
        const menu = document.getElementById("edge-context-menu");
        if (menu && !menu.contains(event.target)) {
          hideEdgeContextMenu();
        }
      });

      // Add event listeners to tooltip after it's created
      function setupTooltipEvents() {
        const tooltip = document.getElementById("tooltip");
        tooltip.addEventListener("mouseenter", keepTooltipVisible);
        tooltip.addEventListener("mouseleave", hideTooltip);
      }

      function resetZoom() {
        const svg = d3.select("#network-graph");
        const zoomBehavior = currentZoom || d3.zoom();
        svg
          .transition()
          .duration(750)
          .call(zoomBehavior.transform, d3.zoomIdentity);
      }

      function fitGraphToViewport() {
        if (!networkData.nodes || networkData.nodes.length === 0) return;

        const svg = d3.select("#network-graph");
        const container = document.querySelector(".graph-container");
        if (!container || svg.empty()) return;

        const width = container.clientWidth;
        const height = container.clientHeight;
        const padding = 60;

        // Compute bounding box of all nodes
        let minX = Infinity,
          minY = Infinity,
          maxX = -Infinity,
          maxY = -Infinity;
        networkData.nodes.forEach((d) => {
          if (d.x < minX) minX = d.x;
          if (d.y < minY) minY = d.y;
          if (d.x > maxX) maxX = d.x;
          if (d.y > maxY) maxY = d.y;
        });

        const graphWidth = maxX - minX;
        const graphHeight = maxY - minY;

        if (graphWidth === 0 && graphHeight === 0) return;

        const scale = Math.min(
          (width - padding * 2) / (graphWidth || 1),
          (height - padding * 2) / (graphHeight || 1),
          2, // cap max zoom so it doesn't over-zoom on small graphs
        );

        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;

        const translateX = width / 2 - centerX * scale;
        const translateY = height / 2 - centerY * scale;

        const transform = d3.zoomIdentity
          .translate(translateX, translateY)
          .scale(scale);

        const zoomBehavior = currentZoom || d3.zoom();
        svg.transition().duration(750).call(zoomBehavior.transform, transform);
      }

      function toggleEdgeLabels() {
        const button = document.getElementById("toggle-edge-labels");
        const edgeLabels = d3.selectAll(".edge-label");

        if (edgeLabelsVisible) {
          // Hide edge labels
          edgeLabels.style("opacity", 0);
          button.textContent = "Show Edge Labels";
          edgeLabelsVisible = false;
        } else {
          // Show edge labels
          edgeLabels.style("opacity", 1);
          button.textContent = "Hide Edge Labels";
          edgeLabelsVisible = true;
        }
      }

      function exportGraph() {
        const dataStr = JSON.stringify(networkData, null, 2);
        const dataBlob = new Blob([dataStr], { type: "application/json" });
        const url = URL.createObjectURL(dataBlob);
        const link = document.createElement("a");
        link.href = url;
        link.download = `network-data-${
          new Date().toISOString().split("T")[0]
        }.json`;
        link.click();
        URL.revokeObjectURL(url);
      }

      function exportGraphAsImage() {
        const svg = document.getElementById("network-graph");
        if (!svg || !networkData || networkData.nodes.length === 0) {
          alert("No graph to export. Please generate a graph first.");
          return;
        }

        // Get the SVG dimensions
        const svgRect = svg.getBoundingClientRect();
        const width = svgRect.width || 800;
        const height = svgRect.height || 600;

        // Clone the SVG to avoid modifying the original
        const svgClone = svg.cloneNode(true);

        // Set explicit width and height on the clone
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        svgClone.setAttribute("xmlns", "http://www.w3.org/2000/svg");
        svgClone.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");

        // Add white background
        const rect = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "rect",
        );
        rect.setAttribute("width", "100%");
        rect.setAttribute("height", "100%");
        rect.setAttribute("fill", "white");
        svgClone.insertBefore(rect, svgClone.firstChild);

        // Ensure all CSS styles are inlined for proper export
        const links = svgClone.querySelectorAll("line");
        links.forEach((link) => {
          const computedStyle = window.getComputedStyle(link);
          link.setAttribute(
            "stroke",
            computedStyle.stroke || link.getAttribute("stroke"),
          );
          link.setAttribute(
            "stroke-width",
            computedStyle.strokeWidth || link.getAttribute("stroke-width"),
          );
          link.setAttribute(
            "stroke-opacity",
            computedStyle.strokeOpacity || "0.7",
          );
          link.setAttribute(
            "stroke-dasharray",
            computedStyle.strokeDasharray ||
              link.getAttribute("stroke-dasharray") ||
              "none",
          );
        });

        // Ensure marker definitions are present and properly sized for export
        let defs = svgClone.querySelector("defs");
        if (!defs) {
          defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
          svgClone.insertBefore(defs, svgClone.firstChild.nextSibling);
        }

        // Add optimized arrow markers specifically for export
        const exportArrowColors = [
          { id: "export-arrow-green", color: "#059669" },
          { id: "export-arrow-red", color: "#dc2626" },
          { id: "export-arrow-blue", color: "#2563eb" },
          { id: "export-arrow-purple", color: "#7c3aed" },
          { id: "export-arrow-orange", color: "#ea580c" },
          { id: "export-arrow-cyan", color: "#0891b2" },
          { id: "export-arrow-gray", color: "#64748b" },
          { id: "export-arrow-default", color: "#94a3b8" },
        ];

        exportArrowColors.forEach((arrow) => {
          const marker = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "marker",
          );
          marker.setAttribute("id", arrow.id);
          marker.setAttribute("viewBox", "0 -3 6 6");
          marker.setAttribute("refX", "18");
          marker.setAttribute("refY", "0");
          marker.setAttribute("markerWidth", "4");
          marker.setAttribute("markerHeight", "4");
          marker.setAttribute("orient", "auto");

          const path = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "path",
          );
          path.setAttribute("d", "M0,-3L6,0L0,3");
          path.setAttribute("fill", arrow.color);
          path.setAttribute("stroke", arrow.color);
          path.setAttribute("stroke-width", "0.3");

          marker.appendChild(path);
          defs.appendChild(marker);
        });

        // Update marker references in exported version
        const exportLinks = svgClone.querySelectorAll("line[marker-end]");
        exportLinks.forEach((link) => {
          const markerEnd = link.getAttribute("marker-end");
          if (markerEnd) {
            const newMarkerEnd = markerEnd.replace("arrow-", "export-arrow-");
            link.setAttribute("marker-end", newMarkerEnd);
          }
        });

        // Serialize the SVG
        const svgData = new XMLSerializer().serializeToString(svgClone);
        const svgBlob = new Blob([svgData], {
          type: "image/svg+xml;charset=utf-8",
        });

        // Create canvas for PNG export
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        canvas.width = width * 2; // Higher resolution
        canvas.height = height * 2;

        const img = new Image();
        img.onload = function () {
          ctx.scale(2, 2); // Scale for higher resolution
          ctx.fillStyle = "white";
          ctx.fillRect(0, 0, width, height);
          ctx.drawImage(img, 0, 0, width, height);

          // Convert to blob and download
          canvas.toBlob(
            function (blob) {
              const url = URL.createObjectURL(blob);
              const link = document.createElement("a");
              link.href = url;
              link.download = `network-graph-${
                new Date().toISOString().split("T")[0]
              }.png`;
              link.click();
              URL.revokeObjectURL(url);
            },
            "image/png",
            1.0,
          );
        };

        img.onerror = function () {
          // Fallback: download as SVG if PNG conversion fails
          const url = URL.createObjectURL(svgBlob);
          const link = document.createElement("a");
          link.href = url;
          link.download = `network-graph-${
            new Date().toISOString().split("T")[0]
          }.svg`;
          link.click();
          URL.revokeObjectURL(url);
        };

        const svgUrl = URL.createObjectURL(svgBlob);
        img.src = svgUrl;
      }

      // Entity management
      async function loadEntitiesForDeletion() {
        if (!connectionStatus.query) {
          document.getElementById("entity-list").innerHTML =
            '<div class="loading">No connection to query service</div>';
          return;
        }

        try {
          const query = `
                    PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
                    PREFIX env: <http://neptune.aws.com/envmgmt/ontology/>
                    
                    SELECT ?entity ?id ?type ?name ?description
                    WHERE {
                        ?entity rdf:type ?type ;
                                env:id ?id ;
                                env:name ?name .
                        OPTIONAL { ?entity env:description ?description }
                        FILTER(STRSTARTS(STR(?type), "http://neptune.aws.com/envmgmt/ontology/"))
                    }
                    ORDER BY ?type ?name
                `;

          const result = await makeApiCall(CONFIG.QUERY_URL, "sparql-query", {
            query,
          });

          if (result.success && result.data && result.data.results) {
            allEntities = result.data.results.bindings.map((binding) => ({
              id: binding.id.value, // Use env:id instead of entity URI
              type: binding.type.value.replace(
                "http://neptune.aws.com/envmgmt/ontology/",
                "",
              ),
              name: binding.name.value,
              description: binding.description ? binding.description.value : "",
            }));

            renderEntityList(allEntities);
          } else {
            document.getElementById("entity-list").innerHTML =
              '<div class="loading">No entities found</div>';
          }
        } catch (error) {
          document.getElementById("entity-list").innerHTML =
            '<div class="loading">Error loading entities</div>';
        }
      }

      function renderEntityList(entities) {
        const container = document.getElementById("entity-list");

        if (entities.length === 0) {
          container.innerHTML =
            '<div class="loading">No entities match your search</div>';
          return;
        }

        container.innerHTML = entities
          .map(
            (entity) => `
                <div class="entity-item">
                    <div class="entity-info">
                        <div class="entity-name">${entity.name}</div>
                        <div class="entity-type">${entity.type}</div>
                        <div class="entity-details">${entity.description}</div>
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="editEntity('${entity.id}', '${entity.name}', '${entity.type}')">
                            Edit
                        </button>
                        <button class="btn btn-danger" onclick="deleteEntity('${entity.id}', '${entity.name}', '${entity.type}')">
                            Delete
                        </button>
                    </div>
                </div>
            `,
          )
          .join("");
      }

      function searchEntities() {
        const searchTerm = document
          .getElementById("search-entity")
          .value.toLowerCase();
        const filteredEntities = allEntities.filter(
          (entity) =>
            entity.name.toLowerCase().includes(searchTerm) ||
            entity.type.toLowerCase().includes(searchTerm) ||
            entity.description.toLowerCase().includes(searchTerm),
        );
        renderEntityList(filteredEntities);
      }

      async function deleteEntity(entityId, entityName, entityType) {
        if (!connectionStatus.query) {
          showAlert(
            "delete-alerts",
            "Cannot delete entity: No connection to query service",
            "error",
          );
          return;
        }

        if (
          !confirm(
            `Delete ${entityType} "${entityName}"?\n\nThis action cannot be undone.`,
          )
        ) {
          return;
        }

        try {
          showAlert(
            "delete-alerts",
            `Deleting ${entityType} "${entityName}"...`,
            "info",
          );

          const result = await makeApiCall(
            CONFIG.CLEANUP_URL,
            "delete-entity",
            {
              entityId: entityId,
              entityType: entityType,
              entityName: entityName,
            },
          );

          if (result.success) {
            showAlert(
              "delete-alerts",
              `${entityType} "${entityName}" deleted successfully!`,
              "success",
            );
            loadEntitiesForDeletion();
          } else {
            showAlert(
              "delete-alerts",
              `Failed to delete ${entityType}: ${
                result.error || "Unknown error"
              }`,
              "error",
            );
          }
        } catch (error) {
          showAlert(
            "delete-alerts",
            `Error deleting ${entityType}: ${error.message}`,
            "error",
          );
        }
      }

      // Edit Entity functions
      async function editEntity(entityId, entityName, entityType) {
        console.log(
          `Opening edit modal for entity: ${entityId}, ${entityName}, ${entityType}`,
        );

        // Clear previous form data
        document.getElementById("edit-entity-form").reset();
        document.getElementById("edit-config-list").innerHTML = "";

        // Set entity identifiers
        document.getElementById("edit-entity-id").value = entityId;
        document.getElementById("edit-entity-type").value = entityType;
        document.getElementById("edit-entity-type-display").textContent =
          entityType;

        // Show/hide type-specific fields
        document.getElementById("edit-environment-fields").style.display =
          entityType === "Environment" ? "block" : "none";
        document.getElementById("edit-application-fields").style.display =
          entityType === "Application" ? "block" : "none";
        document.getElementById("edit-integration-fields").style.display =
          entityType === "Integration" ? "block" : "none";

        // Load entity data
        try {
          const query = `
            PREFIX env: <http://neptune.aws.com/envmgmt/ontology/>
            
            SELECT ?property ?value WHERE {
              ?entity env:id "${entityId}" .
              ?entity ?property ?value .
            }
          `;

          const result = await makeApiCall(CONFIG.QUERY_URL, "sparql-query", {
            query,
          });

          if (result.success && result.data && result.data.results) {
            const bindings = result.data.results.bindings;
            const entityData = {};
            const configurations = {};

            bindings.forEach((binding) => {
              const propUri = binding.property?.value || "";
              const value = binding.value?.value || "";

              if (propUri && value) {
                const propName = propUri.replace(
                  "http://neptune.aws.com/envmgmt/ontology/",
                  "",
                );

                // Check if it's a config property
                if (propName.startsWith("config_")) {
                  const configKey = propName.replace("config_", "");
                  configurations[configKey] = value;
                } else {
                  entityData[propName] = value;
                }
              }
            });

            console.log("Entity data loaded:", entityData);
            console.log("Configurations loaded:", configurations);

            // Populate form fields
            document.getElementById("edit-entity-name").value =
              entityData.name || entityName;
            document.getElementById("edit-entity-description").value =
              entityData.description || "";
            document.getElementById("edit-entity-owner").value =
              entityData.owner || "";
            document.getElementById("edit-entity-status").value =
              entityData.status || "active";

            // Type-specific fields
            if (entityType === "Environment") {
              document.getElementById("edit-env-region").value =
                entityData.region || configurations.region || "";
              document.getElementById("edit-env-endpoint").value =
                entityData.endpoint || configurations.endpoint || "";
            } else if (entityType === "Application") {
              document.getElementById("edit-app-version").value =
                entityData.version || configurations.version || "";
            } else if (entityType === "Integration") {
              document.getElementById("edit-int-protocol").value =
                entityData.protocol || configurations.protocol || "";
              document.getElementById("edit-int-source").value =
                entityData.sourceService || configurations.sourceService || "";
              document.getElementById("edit-int-target").value =
                entityData.targetService || configurations.targetService || "";
            }

            // Load custom configurations (excluding type-specific ones already handled)
            const excludeConfigKeys = [
              "region",
              "endpoint",
              "version",
              "protocol",
              "sourceService",
              "targetService",
            ];
            Object.entries(configurations).forEach(([key, value]) => {
              if (!excludeConfigKeys.includes(key)) {
                addEditConfigField(key, value);
              }
            });

            // Auto-expand config section if there are custom configs
            const customConfigCount = Object.keys(configurations).filter(
              (k) => !excludeConfigKeys.includes(k),
            ).length;
            if (customConfigCount > 0) {
              document.getElementById("edit-config-section").style.display =
                "block";
              document.getElementById(
                "edit-config-toggle-icon",
              ).style.transform = "rotate(90deg)";
            } else {
              document.getElementById("edit-config-section").style.display =
                "none";
              document.getElementById(
                "edit-config-toggle-icon",
              ).style.transform = "rotate(0deg)";
            }

            // Show modal
            document.getElementById("edit-modal").style.display = "block";
            showAlert("edit-alerts", "", "");
          } else {
            showAlert(
              "delete-alerts",
              "Failed to load entity data for editing",
              "error",
            );
          }
        } catch (error) {
          console.error("Error loading entity for edit:", error);
          showAlert(
            "delete-alerts",
            `Error loading entity: ${error.message}`,
            "error",
          );
        }
      }

      function closeEditModal() {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("edit-entity-form").reset();
        document.getElementById("edit-config-list").innerHTML = "";
        document.getElementById("edit-config-csv-preview").style.display =
          "none";
        document.getElementById("edit-config-csv-preview-content").innerHTML =
          "";
      }

      function addEditConfigField(key = "", value = "") {
        const configContainer = document.getElementById("edit-config-list");
        const configId = "edit_config_" + Date.now() + "_" + Math.random();

        const configHtml = `
          <div class="config-item" id="${configId}">
            <input type="text" class="form-input config-key" placeholder="Key" value="${key}" required />
            <input type="text" class="form-input config-value" placeholder="Value" value="${value}" required />
            <button type="button" class="remove-config" onclick="document.getElementById('${configId}').remove()">×</button>
          </div>
        `;

        configContainer.insertAdjacentHTML("beforeend", configHtml);
      }

      function getEditConfigurations() {
        const configurations = {};
        const configItems = document.querySelectorAll(
          "#edit-config-list .config-item",
        );

        configItems.forEach((item) => {
          const key = item.querySelector(".config-key").value.trim();
          const value = item.querySelector(".config-value").value.trim();

          if (key && value) {
            configurations[key] = value;
          }
        });

        return configurations;
      }

      async function saveEntityEdit(event) {
        event.preventDefault();

        const entityId = document.getElementById("edit-entity-id").value;
        const entityType = document.getElementById("edit-entity-type").value;
        const entityName = document.getElementById("edit-entity-name").value;

        const updateData = {
          id: entityId,
          name: entityName,
          type: entityType,
          description: document.getElementById("edit-entity-description").value,
          owner: document.getElementById("edit-entity-owner").value,
          status: document.getElementById("edit-entity-status").value,
        };

        // Collect type-specific fields and configurations
        const configurations = {};

        if (entityType === "Environment") {
          const region = document.getElementById("edit-env-region").value;
          const endpoint = document.getElementById("edit-env-endpoint").value;
          if (region) configurations.region = region;
          if (endpoint) configurations.endpoint = endpoint;
        } else if (entityType === "Application") {
          const version = document.getElementById("edit-app-version").value;
          if (version) configurations.version = version;
        } else if (entityType === "Integration") {
          const protocol = document.getElementById("edit-int-protocol").value;
          const source = document.getElementById("edit-int-source").value;
          const target = document.getElementById("edit-int-target").value;
          if (protocol) configurations.protocol = protocol;
          if (source) configurations.sourceService = source;
          if (target) configurations.targetService = target;
        }

        // Add custom configurations
        Object.assign(configurations, getEditConfigurations());

        if (Object.keys(configurations).length > 0) {
          updateData.configurations = configurations;
        }

        console.log("Saving entity update:", updateData);

        try {
          showAlert("edit-alerts", "Saving changes...", "info");

          // Delete old entity and create new one with updated data (Neptune doesn't have direct update)
          const result = await makeApiCall(
            CONFIG.INGEST_URL,
            "update-entity",
            updateData,
          );

          if (result.success) {
            showAlert("edit-alerts", "Entity updated successfully!", "success");
            setTimeout(() => {
              closeEditModal();
              loadEntitiesForDeletion();
              // Refresh visualization if on that tab
              if (
                document
                  .getElementById("visualize")
                  .classList.contains("active")
              ) {
                loadNetworkData();
              }
            }, 1500);
          } else {
            showAlert(
              "edit-alerts",
              `Failed to update entity: ${result.error || "Unknown error"}`,
              "error",
            );
          }
        } catch (error) {
          console.error("Error updating entity:", error);
          showAlert(
            "edit-alerts",
            `Error updating entity: ${error.message}`,
            "error",
          );
        }
      }

      // Admin functions
      async function healthCheck() {
        if (!connectionStatus.query) {
          document.getElementById("admin-results").innerHTML =
            '<div class="alert alert-error">No connection to query service</div>';
          return;
        }

        try {
          document.getElementById("admin-results").innerHTML =
            '<div class="loading"><div class="spinner"></div>Checking system health...</div>';

          const result = await makeApiCall(CONFIG.QUERY_URL, "health");

          if (result.success) {
            document.getElementById("admin-results").innerHTML = `
                        <div><strong>System Health Check</strong></div>
                        <div style="margin-top: 0.5rem;">Status: <span style="color: var(--success-color); font-weight: 600;">HEALTHY</span></div>
                        <div>Timestamp: ${new Date(
                          result.timestamp,
                        ).toLocaleString()}</div>
                        <div>Neptune Connection: Active</div>
                        <div>Lambda Functions: Operational</div>
                    `;
          } else {
            document.getElementById("admin-results").innerHTML = `
                        <div><strong>System Health Check</strong></div>
                        <div style="margin-top: 0.5rem;">Status: <span style="color: var(--danger-color); font-weight: 600;">ERROR</span></div>
                        <div>Error: ${result.error || "Unknown error"}</div>
                    `;
          }
        } catch (error) {
          document.getElementById("admin-results").innerHTML = `
                    <div><strong>System Health Check</strong></div>
                    <div style="margin-top: 0.5rem;">Status: <span style="color: var(--danger-color); font-weight: 600;">FAILED</span></div>
                    <div>Error: ${error.message}</div>
                `;
        }
      }

      async function getEntityCounts() {
        if (!connectionStatus.query) {
          document.getElementById("admin-results").innerHTML =
            '<div class="alert alert-error">No connection to query service</div>';
          return;
        }

        try {
          document.getElementById("admin-results").innerHTML =
            '<div class="loading"><div class="spinner"></div>Getting entity counts...</div>';

          const query = `
                    PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
                    
                    SELECT ?type (COUNT(?entity) as ?count)
                    WHERE {
                        ?entity rdf:type ?type .
                    }
                    GROUP BY ?type
                    ORDER BY DESC(?count)
                `;

          const result = await makeApiCall(CONFIG.QUERY_URL, "sparql-query", {
            query,
          });

          if (result.success && result.data && result.data.results) {
            const bindings = result.data.results.bindings;
            let html =
              '<div><strong>Entity Counts</strong></div><div style="margin-top: 1rem;">';

            let total = 0;
            bindings.forEach((binding) => {
              const type = binding.type.value
                .replace("http://neptune.aws.com/envmgmt/ontology/", "")
                .replace("http://www.w3.org/2002/07/owl#", "OWL:");
              const count = parseInt(binding.count.value);
              total += count;
              html += `<div>${type}: ${count}</div>`;
            });

            html += `</div><div style="margin-top: 1rem; font-weight: 600;">Total: ${total} entities</div>`;
            document.getElementById("admin-results").innerHTML = html;
          } else {
            document.getElementById("admin-results").innerHTML =
              '<div class="alert alert-error">Error getting entity counts</div>';
          }
        } catch (error) {
          document.getElementById("admin-results").innerHTML =
            `<div class="alert alert-error">Error: ${error.message}</div>`;
        }
      }

      // CSV Config Upload in Edit Modal
      function handleEditConfigCsvUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        if (!file.name.toLowerCase().endsWith(".csv")) {
          showAlert("edit-alerts", "Please upload a .csv file", "error");
          event.target.value = "";
          return;
        }

        const reader = new FileReader();
        reader.onload = function (e) {
          try {
            const content = e.target.result;
            const configs = parseEditConfigCsv(content);

            if (configs.length === 0) {
              showAlert(
                "edit-alerts",
                "No valid config entries found in CSV",
                "error",
              );
              return;
            }

            // Add each config as a field in the edit form
            configs.forEach((c) => addEditConfigField(c.key, c.value));

            // Build preview (escape HTML to prevent XSS)
            let previewHtml = `<table style="width: 100%; border-collapse: collapse; font-size: 0.8rem;">`;
            previewHtml += `<tr><th style="text-align: left; padding: 3px 8px; border-bottom: 1px solid var(--border-color); color: var(--text-secondary);">Key</th><th style="text-align: left; padding: 3px 8px; border-bottom: 1px solid var(--border-color); color: var(--text-secondary);">Value</th></tr>`;
            configs.forEach((c) => {
              const escapedKey = escapeHtml(c.key);
              const escapedValue = escapeHtml(
                c.value.length > 100
                  ? c.value.substring(0, 100) + "..."
                  : c.value,
              );
              previewHtml += `<tr><td style="padding: 3px 8px; border-bottom: 1px solid var(--border-color); word-break: break-word;">${escapedKey}</td><td style="padding: 3px 8px; border-bottom: 1px solid var(--border-color); word-break: break-word; white-space: pre-wrap;">${escapedValue}</td></tr>`;
            });
            previewHtml += `</table>`;

            document.getElementById(
              "edit-config-csv-preview-content",
            ).innerHTML = previewHtml;
            document.getElementById("edit-config-csv-preview").style.display =
              "block";

            showAlert(
              "edit-alerts",
              `Loaded ${configs.length} config entries from CSV. Click "Save Changes" to apply.`,
              "success",
            );
          } catch (error) {
            showAlert(
              "edit-alerts",
              "Error parsing CSV: " + error.message,
              "error",
            );
          }
          event.target.value = "";
        };
        reader.onerror = function () {
          showAlert("edit-alerts", "Failed to read CSV file", "error");
          event.target.value = "";
        };
        reader.readAsText(file);
      }

      function parseEditConfigCsv(csvContent) {
        // Parse CSV into rows respecting quoted fields
        const rows = parseCSVRows(csvContent);

        if (rows.length < 2) {
          throw new Error(
            "CSV must have a header row and at least one data row",
          );
        }

        // Parse headers
        const headers = rows[0].map((h) => h.trim().toLowerCase());

        const keyIdx = headers.findIndex(
          (h) => h === "config_key" || h === "key",
        );
        const valueIdx = headers.findIndex(
          (h) => h === "config_value" || h === "value",
        );

        if (keyIdx === -1 || valueIdx === -1) {
          throw new Error(
            "CSV must have columns: config_key (or key), config_value (or value)",
          );
        }

        const configs = [];
        for (let i = 1; i < rows.length; i++) {
          const row = rows[i];
          const key = (row[keyIdx] || "").trim();
          const value = (row[valueIdx] || "").trim();

          if (key && value) {
            configs.push({ key, value });
          }
        }

        return configs;
      }

      // Robust CSV parser that handles quoted fields with special characters
      function parseCSVRows(csvContent) {
        const rows = [];
        let currentRow = [];
        let currentField = "";
        let inQuotes = false;
        let i = 0;

        while (i < csvContent.length) {
          const char = csvContent[i];
          const nextChar = csvContent[i + 1];

          if (char === '"') {
            if (inQuotes && nextChar === '"') {
              // Escaped quote ("" within quoted field)
              currentField += '"';
              i += 2;
              continue;
            } else {
              // Toggle quote mode
              inQuotes = !inQuotes;
              i++;
              continue;
            }
          }

          if (!inQuotes) {
            if (char === ",") {
              // End of field
              currentRow.push(currentField);
              currentField = "";
              i++;
              continue;
            } else if (char === "\n" || char === "\r") {
              // End of row
              currentRow.push(currentField);
              if (currentRow.some((f) => f.trim())) {
                // Only add non-empty rows
                rows.push(currentRow);
              }
              currentRow = [];
              currentField = "";
              // Skip \r\n combination
              if (char === "\r" && nextChar === "\n") {
                i += 2;
              } else {
                i++;
              }
              continue;
            }
          }

          // Regular character
          currentField += char;
          i++;
        }

        // Handle last field/row
        if (currentField || currentRow.length > 0) {
          currentRow.push(currentField);
          if (currentRow.some((f) => f.trim())) {
            rows.push(currentRow);
          }
        }

        return rows;
      }

      function toggleConfigDetails() {
        const details = document.getElementById("config-details");
        const header = details.previousElementSibling;
        if (details.style.display === "none") {
          details.style.display = "block";
          header.innerHTML = header.innerHTML.replace("[Show]", "[Hide]");
        } else {
          details.style.display = "none";
          header.innerHTML = header.innerHTML.replace("[Hide]", "[Show]");
        }
      }

      // Helper function to escape HTML special characters
      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // Bulk Import Functions
      function handleBulkFileUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        const fileName = file.name.toLowerCase();

        if (fileName.endsWith(".json")) {
          handleJsonFileUpload(file);
        } else if (fileName.endsWith(".csv")) {
          handleCsvFileUpload(file);
        } else if (fileName.endsWith(".xlsx") || fileName.endsWith(".xls")) {
          handleExcelFileUpload(file);
        } else {
          showAlert(
            "bulk-alerts",
            "Unsupported file type. Please upload JSON, CSV, or Excel file.",
            "error",
          );
        }
      }

      function handleJsonFileUpload(file) {
        const reader = new FileReader();
        reader.onload = function (e) {
          try {
            const content = e.target.result;
            document.getElementById("bulk-json-input").value = content;
            validateBulkJson();
            showAlert(
              "bulk-alerts",
              `JSON file "${file.name}" loaded successfully`,
              "success",
            );
          } catch (error) {
            showAlert(
              "bulk-alerts",
              "Error reading JSON file: " + error.message,
              "error",
            );
          }
        };
        reader.onerror = function () {
          showAlert("bulk-alerts", "Failed to read file", "error");
        };
        reader.readAsText(file);
      }

      function handleCsvFileUpload(file) {
        const reader = new FileReader();
        reader.onload = function (e) {
          try {
            const content = e.target.result;
            const entities = parseCsvToEntities(content);
            const jsonData = { entities };
            document.getElementById("bulk-json-input").value = JSON.stringify(
              jsonData,
              null,
              2,
            );
            validateBulkJson();
            showAlert(
              "bulk-alerts",
              `CSV file "${file.name}" loaded successfully (${entities.length} entities)`,
              "success",
            );
          } catch (error) {
            showAlert(
              "bulk-alerts",
              "Error parsing CSV file: " + error.message,
              "error",
            );
          }
        };
        reader.onerror = function () {
          showAlert("bulk-alerts", "Failed to read CSV file", "error");
        };
        reader.readAsText(file);
      }

      function handleExcelFileUpload(file) {
        const reader = new FileReader();
        reader.onload = function (e) {
          try {
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: "array" });
            const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
            const csvContent = XLSX.utils.sheet_to_csv(firstSheet);
            const entities = parseCsvToEntities(csvContent);
            const jsonData = { entities };
            document.getElementById("bulk-json-input").value = JSON.stringify(
              jsonData,
              null,
              2,
            );
            validateBulkJson();
            showAlert(
              "bulk-alerts",
              `Excel file "${file.name}" loaded successfully (${entities.length} entities)`,
              "success",
            );
          } catch (error) {
            showAlert(
              "bulk-alerts",
              "Error parsing Excel file: " + error.message,
              "error",
            );
          }
        };
        reader.onerror = function () {
          showAlert("bulk-alerts", "Failed to read Excel file", "error");
        };
        reader.readAsArrayBuffer(file);
      }

      function parseCsvToEntities(csvContent) {
        // Parse CSV into rows respecting quoted fields
        const rows = parseCSVRows(csvContent);

        if (rows.length < 2) {
          throw new Error(
            "CSV file must have headers and at least one data row",
          );
        }

        // Parse headers
        const headers = rows[0].map((h) => h.trim());
        const entities = [];

        // Parse each row
        for (let i = 1; i < rows.length; i++) {
          const values = rows[i];
          if (values.length === 0 || !values[0]) continue; // Skip empty rows

          const entity = {};
          const configurations = {};
          const configPairs = {}; // Store config_key/config_value pairs
          let sourceEntity = "";
          let relationshipType = "";
          let targetEntity = "";

          // Map CSV columns to entity properties
          headers.forEach((header, index) => {
            const value = values[index] ? values[index].trim() : "";
            if (!value) return;

            const headerLower = header.toLowerCase();

            // Core fields
            if (headerLower === "type") entity.type = value;
            else if (headerLower === "name") entity.name = value;
            else if (headerLower === "description") entity.description = value;
            else if (headerLower === "owner") entity.owner = value;
            // Environment-specific
            else if (headerLower === "region") entity.region = value;
            else if (headerLower === "endpoint") entity.endpoint = value;
            // Application-specific
            else if (headerLower === "version") entity.version = value;
            // Integration-specific
            else if (headerLower === "sourceservice")
              entity.sourceService = value;
            else if (headerLower === "targetservice")
              entity.targetService = value;
            else if (headerLower === "protocol") entity.protocol = value;
            // Relationship fields
            else if (headerLower === "sourceentity") sourceEntity = value;
            else if (headerLower === "relationshiptype")
              relationshipType = value;
            else if (headerLower === "targetentity") targetEntity = value;
            // Configuration key/value pairs (config_key1, config_value1, config_key2, config_value2, etc.)
            else if (headerLower.match(/^config_key(\d*)$/)) {
              const num = headerLower.match(/^config_key(\d*)$/)[1];
              configPairs[`key${num}`] = value;
            } else if (headerLower.match(/^config_value(\d*)$/)) {
              const num = headerLower.match(/^config_value(\d*)$/)[1];
              configPairs[`value${num}`] = value;
            }
          });

          // Process config pairs into configurations object
          const keyNumbers = Object.keys(configPairs)
            .filter((k) => k.startsWith("key"))
            .map((k) => k.replace("key", ""));

          keyNumbers.forEach((num) => {
            const key = configPairs[`key${num}`];
            const value = configPairs[`value${num}`];
            if (key && value) {
              configurations[key] = value;
            }
          });

          // Validate required fields
          if (!entity.type || !entity.name) {
            console.warn(`Skipping row ${i + 1}: missing type or name`);
            continue;
          }

          // Add configurations if any
          if (Object.keys(configurations).length > 0) {
            entity.configurations = configurations;
          }

          // Add relationships if specified (FROM this entity TO target)
          if (targetEntity && relationshipType) {
            if (!entity.relationships) {
              entity.relationships = [];
            }
            entity.relationships.push({
              type: relationshipType,
              target: targetEntity,
            });
          }

          // Store sourceEntity info for second pass
          if (sourceEntity) {
            entity._sourceEntity = sourceEntity;
            entity._sourceRelationshipType = relationshipType || "integrates";
          }

          entities.push(entity);
        }

        // Second pass: Create relationships from sourceEntity to current entity
        entities.forEach((entity) => {
          if (entity._sourceEntity) {
            // Find the source entity in the array
            const sourceEnt = entities.find(
              (e) => e.name === entity._sourceEntity,
            );
            if (sourceEnt) {
              // Source entity is in the CSV - add relationship to it
              if (!sourceEnt.relationships) {
                sourceEnt.relationships = [];
              }
              sourceEnt.relationships.push({
                type: entity._sourceRelationshipType,
                target: entity.name,
              });
            } else {
              // Source entity NOT in CSV - add reverse relationship to current entity
              // Backend will create relationship FROM sourceEntity TO this entity
              if (!entity.incomingRelationships) {
                entity.incomingRelationships = [];
              }
              entity.incomingRelationships.push({
                from: entity._sourceEntity,
                type: entity._sourceRelationshipType,
              });
            }
            // Clean up temporary properties
            delete entity._sourceEntity;
            delete entity._sourceRelationshipType;
          }
        });

        return entities;
      }

      function formatBulkJson() {
        const textarea = document.getElementById("bulk-json-input");
        const value = textarea.value.trim();

        if (!value) {
          showAlert("bulk-alerts", "No JSON to format", "warning");
          return;
        }

        try {
          const parsed = JSON.parse(value);
          textarea.value = JSON.stringify(parsed, null, 2);
          showAlert("bulk-alerts", "JSON formatted successfully", "success");
        } catch (error) {
          showAlert("bulk-alerts", "Invalid JSON: " + error.message, "error");
        }
      }

      function validateBulkJson() {
        const textarea = document.getElementById("bulk-json-input");
        const value = textarea.value.trim();
        const previewDiv = document.getElementById("bulk-preview");
        const previewContent = document.getElementById("bulk-preview-content");

        if (!value) {
          previewDiv.style.display = "none";
          showAlert("bulk-alerts", "No JSON to validate", "warning");
          return;
        }

        try {
          const parsed = JSON.parse(value);

          // Validate structure
          if (!parsed.entities || !Array.isArray(parsed.entities)) {
            throw new Error(
              'JSON must have an "entities" array at the top level',
            );
          }

          if (parsed.entities.length === 0) {
            throw new Error("Entities array is empty");
          }

          // Validate each entity
          const errors = [];
          const warnings = [];
          parsed.entities.forEach((entity, index) => {
            if (!entity.type) {
              errors.push(`Entity ${index + 1}: Missing "type" field`);
            }
            if (!entity.name) {
              errors.push(`Entity ${index + 1}: Missing "name" field`);
            }
            if (!entity.description) {
              warnings.push(`Entity ${index + 1}: Missing "description" field`);
            }
          });

          if (errors.length > 0) {
            showAlert(
              "bulk-alerts",
              "Validation errors: " + errors.join("; "),
              "error",
            );
            previewDiv.style.display = "none";
            return;
          }

          // Show preview
          previewContent.innerHTML = `
            <div><strong>Total Entities:</strong> ${parsed.entities.length}</div>
            <div style="margin-top: 0.5rem;"><strong>Entity Types:</strong></div>
            <ul style="margin-left: 1.5rem; margin-top: 0.25rem;">
              ${Object.entries(
                parsed.entities.reduce((acc, e) => {
                  acc[e.type] = (acc[e.type] || 0) + 1;
                  return acc;
                }, {}),
              )
                .map(([type, count]) => `<li>${type}: ${count}</li>`)
                .join("")}
            </ul>
            ${warnings.length > 0 ? `<div style="margin-top: 0.5rem; color: var(--warning-color);"><strong>Warnings:</strong> ${warnings.join("; ")}</div>` : ""}
          `;
          previewDiv.style.display = "block";

          showAlert(
            "bulk-alerts",
            `JSON is valid! Ready to import ${parsed.entities.length} entities`,
            "success",
          );
        } catch (error) {
          previewDiv.style.display = "none";
          showAlert("bulk-alerts", "Invalid JSON: " + error.message, "error");
        }
      }

      function clearBulkJson() {
        document.getElementById("bulk-json-input").value = "";
        document.getElementById("bulk-file-input").value = "";
        document.getElementById("bulk-preview").style.display = "none";
        document.getElementById("bulk-results").style.display = "none";
        showAlert("bulk-alerts", "Cleared", "info");
      }

      async function submitBulkImport() {
        if (!connectionStatus.ingest) {
          showAlert(
            "bulk-alerts",
            "Cannot import: No connection to ingest service",
            "error",
          );
          return;
        }

        const textarea = document.getElementById("bulk-json-input");
        const value = textarea.value.trim();

        if (!value) {
          showAlert("bulk-alerts", "No JSON data to import", "warning");
          return;
        }

        let parsedData;
        try {
          parsedData = JSON.parse(value);

          if (!parsedData.entities || !Array.isArray(parsedData.entities)) {
            throw new Error(
              'JSON must have an "entities" array at the top level',
            );
          }

          if (parsedData.entities.length === 0) {
            throw new Error("Entities array is empty");
          }
        } catch (error) {
          showAlert("bulk-alerts", "Invalid JSON: " + error.message, "error");
          return;
        }

        const confirmation = confirm(
          `Import ${parsedData.entities.length} entities?\n\nThis will create all entities in the database.`,
        );

        if (!confirmation) return;

        try {
          showAlert(
            "bulk-alerts",
            `Importing ${parsedData.entities.length} entities...`,
            "info",
          );

          const result = await makeApiCall(
            CONFIG.INGEST_URL,
            "bulk-ingest",
            parsedData,
          );

          if (result.success && result.data) {
            const data = result.data;
            const resultsDiv = document.getElementById("bulk-results");
            const resultsContent = document.getElementById(
              "bulk-results-content",
            );

            let html = `
              <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; margin-bottom: 1rem;">
                <div style="padding: 1rem; background: var(--bg-tertiary); border-radius: 0.375rem; text-align: center;">
                  <div style="font-size: 1.5rem; font-weight: 600;">${data.total}</div>
                  <div style="font-size: 0.875rem; color: var(--text-secondary);">Total</div>
                </div>
                <div style="padding: 1rem; background: #dcfce7; border-radius: 0.375rem; text-align: center;">
                  <div style="font-size: 1.5rem; font-weight: 600; color: #166534;">${data.successful}</div>
                  <div style="font-size: 0.875rem; color: #166534;">Successful</div>
                </div>
                <div style="padding: 1rem; background: #fee2e2; border-radius: 0.375rem; text-align: center;">
                  <div style="font-size: 1.5rem; font-weight: 600; color: #991b1b;">${data.failed}</div>
                  <div style="font-size: 0.875rem; color: #991b1b;">Failed</div>
                </div>
              </div>
            `;

            if (data.results && data.results.length > 0) {
              html += `
                <div style="max-height: 400px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 0.375rem;">
                  <table class="query-table" style="margin: 0;">
                    <thead>
                      <tr>
                        <th>#</th>
                        <th>Name</th>
                        <th>Type</th>
                        <th>Status</th>
                        <th>Details</th>
                      </tr>
                    </thead>
                    <tbody>
              `;

              data.results.forEach((item) => {
                const statusColor =
                  item.status === "success"
                    ? "var(--success-color)"
                    : "var(--danger-color)";
                const details =
                  item.status === "success"
                    ? `ID: ${item.id}`
                    : item.error || "Unknown error";

                html += `
                  <tr>
                    <td>${item.index + 1}</td>
                    <td>${item.name}</td>
                    <td>${item.type}</td>
                    <td style="color: ${statusColor}; font-weight: 500;">${item.status}</td>
                    <td style="font-size: 0.8rem;">${details}</td>
                  </tr>
                `;
              });

              html += `
                    </tbody>
                  </table>
                </div>
              `;
            }

            resultsContent.innerHTML = html;
            resultsDiv.style.display = "block";

            showAlert(
              "bulk-alerts",
              `Import completed: ${data.successful} successful, ${data.failed} failed`,
              data.failed === 0 ? "success" : "warning",
            );

            // Refresh entity lists if on manage entities tab
            if (data.successful > 0) {
              loadEntitiesForDeletion();
            }
          } else {
            showAlert(
              "bulk-alerts",
              "Import failed: " + (result.error || "Unknown error"),
              "error",
            );
          }
        } catch (error) {
          showAlert(
            "bulk-alerts",
            "Error during import: " + error.message,
            "error",
          );
        }
      }

      async function deleteAllEntities() {
        if (!connectionStatus.query) {
          alert("Cannot delete data: No connection to query service");
          return;
        }

        const confirmation = prompt(
          'This will DELETE ALL DATA!\n\nType "DELETE ALL" to confirm:',
        );

        if (confirmation !== "DELETE ALL") {
          return;
        }

        try {
          document.getElementById("admin-results").innerHTML =
            '<div class="loading"><div class="spinner"></div>Deleting all data...</div>';

          const result = await makeApiCall(
            CONFIG.CLEANUP_URL,
            "delete-all-data",
          );

          if (result.success) {
            document.getElementById("admin-results").innerHTML = `
                        <div><strong>All Data Deleted</strong></div>
                        <div style="margin-top: 0.5rem;">All entities and relationships have been removed.</div>
                        <div>Timestamp: ${new Date().toLocaleString()}</div>
                    `;

            loadEntitiesForDeletion();
            networkData = { nodes: [], edges: [] };
            document.getElementById("node-count").textContent = "0";
            document.getElementById("edge-count").textContent = "0";
          } else {
            document.getElementById("admin-results").innerHTML = `
                        <div class="alert alert-error">Delete failed: ${
                          result.error || "Unknown error"
                        }</div>
                    `;
          }
        } catch (error) {
          document.getElementById("admin-results").innerHTML = `
                    <div class="alert alert-error">Delete failed: ${error.message}</div>
                `;
        }
      }
    </script>
  </body>
</html>
